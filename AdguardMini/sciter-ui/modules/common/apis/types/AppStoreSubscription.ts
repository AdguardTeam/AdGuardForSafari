/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.32.1
 * source: AppStoreSubscription.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as pb_1 from "google-protobuf";
export enum AppStoreSubscription {
    monthly = 0,
    annual = 1
}
export enum AppStoreSubscriptionsError {
    unknown = 0,
    products_banned = 1,
    other_error = 2
}
export class AppStoreSubscriptionInfo extends pb_1.Message {
    #one_of_decls: number[][] = [[4]];
    constructor(data?: any[] | ({
        subscriptionType?: AppStoreSubscription;
        displayPrice?: string;
        trialDays?: number;
    } & (({
        introOfferDisplayPrice?: string;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("subscriptionType" in data && data.subscriptionType != undefined) {
                this.subscriptionType = data.subscriptionType;
            }
            if ("displayPrice" in data && data.displayPrice != undefined) {
                this.displayPrice = data.displayPrice;
            }
            if ("trialDays" in data && data.trialDays != undefined) {
                this.trialDays = data.trialDays;
            }
            if ("introOfferDisplayPrice" in data && data.introOfferDisplayPrice != undefined) {
                this.introOfferDisplayPrice = data.introOfferDisplayPrice;
            }
        }
    }
    get subscriptionType() {
        return pb_1.Message.getFieldWithDefault(this, 1, AppStoreSubscription.monthly) as AppStoreSubscription;
    }
    set subscriptionType(value: AppStoreSubscription) {
        pb_1.Message.setField(this, 1, value);
    }
    get displayPrice() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set displayPrice(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    get trialDays() {
        return pb_1.Message.getFieldWithDefault(this, 3, 0) as number;
    }
    set trialDays(value: number) {
        pb_1.Message.setField(this, 3, value);
    }
    get introOfferDisplayPrice() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set introOfferDisplayPrice(value: string) {
        pb_1.Message.setOneofField(this, 4, this.#one_of_decls[0], value);
    }
    get has_intro_offer_display_price() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get _introOfferDisplayPrice() {
        const cases: {
            [index: number]: "none" | "introOfferDisplayPrice";
        } = {
            0: "none",
            4: "introOfferDisplayPrice"
        };
        return cases[pb_1.Message.computeOneofCase(this, [4])];
    }
    static fromObject(data: {
        subscriptionType?: AppStoreSubscription;
        displayPrice?: string;
        trialDays?: number;
        introOfferDisplayPrice?: string;
    }): AppStoreSubscriptionInfo {
        const message = new AppStoreSubscriptionInfo({});
        if (data.subscriptionType != null) {
            message.subscriptionType = data.subscriptionType;
        }
        if (data.displayPrice != null) {
            message.displayPrice = data.displayPrice;
        }
        if (data.trialDays != null) {
            message.trialDays = data.trialDays;
        }
        if (data.introOfferDisplayPrice != null) {
            message.introOfferDisplayPrice = data.introOfferDisplayPrice;
        }
        return message;
    }
    toObject() {
        const data: {
            subscriptionType?: AppStoreSubscription;
            displayPrice?: string;
            trialDays?: number;
            introOfferDisplayPrice?: string;
        } = {};
        if (this.subscriptionType != null) {
            data.subscriptionType = this.subscriptionType;
        }
        if (this.displayPrice != null) {
            data.displayPrice = this.displayPrice;
        }
        if (this.trialDays != null) {
            data.trialDays = this.trialDays;
        }
        if (this.introOfferDisplayPrice != null) {
            data.introOfferDisplayPrice = this.introOfferDisplayPrice;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.subscriptionType != AppStoreSubscription.monthly)
            writer.writeEnum(1, this.subscriptionType);
        if (this.displayPrice.length)
            writer.writeString(2, this.displayPrice);
        if (this.trialDays != 0)
            writer.writeInt32(3, this.trialDays);
        if (this.has_intro_offer_display_price)
            writer.writeString(4, this.introOfferDisplayPrice);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AppStoreSubscriptionInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AppStoreSubscriptionInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.subscriptionType = reader.readEnum();
                    break;
                case 2:
                    message.displayPrice = reader.readString();
                    break;
                case 3:
                    message.trialDays = reader.readInt32();
                    break;
                case 4:
                    message.introOfferDisplayPrice = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AppStoreSubscriptionInfo {
        return AppStoreSubscriptionInfo.deserialize(bytes);
    }
}
export class PromoInfo extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        title?: string;
        subtitle?: string;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("title" in data && data.title != undefined) {
                this.title = data.title;
            }
            if ("subtitle" in data && data.subtitle != undefined) {
                this.subtitle = data.subtitle;
            }
        }
    }
    get title() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set title(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get subtitle() {
        return pb_1.Message.getFieldWithDefault(this, 2, "") as string;
    }
    set subtitle(value: string) {
        pb_1.Message.setField(this, 2, value);
    }
    static fromObject(data: {
        title?: string;
        subtitle?: string;
    }): PromoInfo {
        const message = new PromoInfo({});
        if (data.title != null) {
            message.title = data.title;
        }
        if (data.subtitle != null) {
            message.subtitle = data.subtitle;
        }
        return message;
    }
    toObject() {
        const data: {
            title?: string;
            subtitle?: string;
        } = {};
        if (this.title != null) {
            data.title = this.title;
        }
        if (this.subtitle != null) {
            data.subtitle = this.subtitle;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.title.length)
            writer.writeString(1, this.title);
        if (this.subtitle.length)
            writer.writeString(2, this.subtitle);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): PromoInfo {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new PromoInfo();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.title = reader.readString();
                    break;
                case 2:
                    message.subtitle = reader.readString();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): PromoInfo {
        return PromoInfo.deserialize(bytes);
    }
}
export class AppStoreSubscriptions extends pb_1.Message {
    #one_of_decls: number[][] = [[4]];
    constructor(data?: any[] | ({
        isTrialAvailable?: boolean;
        monthly?: AppStoreSubscriptionInfo;
        annual?: AppStoreSubscriptionInfo;
    } & (({
        promoInfo?: PromoInfo;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("isTrialAvailable" in data && data.isTrialAvailable != undefined) {
                this.isTrialAvailable = data.isTrialAvailable;
            }
            if ("monthly" in data && data.monthly != undefined) {
                this.monthly = data.monthly;
            }
            if ("annual" in data && data.annual != undefined) {
                this.annual = data.annual;
            }
            if ("promoInfo" in data && data.promoInfo != undefined) {
                this.promoInfo = data.promoInfo;
            }
        }
    }
    get isTrialAvailable() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set isTrialAvailable(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get monthly() {
        return pb_1.Message.getWrapperField(this, AppStoreSubscriptionInfo, 2) as AppStoreSubscriptionInfo;
    }
    set monthly(value: AppStoreSubscriptionInfo) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_monthly() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get annual() {
        return pb_1.Message.getWrapperField(this, AppStoreSubscriptionInfo, 3) as AppStoreSubscriptionInfo;
    }
    set annual(value: AppStoreSubscriptionInfo) {
        pb_1.Message.setWrapperField(this, 3, value);
    }
    get has_annual() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get promoInfo() {
        return pb_1.Message.getWrapperField(this, PromoInfo, 4) as PromoInfo;
    }
    set promoInfo(value: PromoInfo) {
        pb_1.Message.setOneofWrapperField(this, 4, this.#one_of_decls[0], value);
    }
    get has_promoInfo() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get _promoInfo() {
        const cases: {
            [index: number]: "none" | "promoInfo";
        } = {
            0: "none",
            4: "promoInfo"
        };
        return cases[pb_1.Message.computeOneofCase(this, [4])];
    }
    static fromObject(data: {
        isTrialAvailable?: boolean;
        monthly?: ReturnType<typeof AppStoreSubscriptionInfo.prototype.toObject>;
        annual?: ReturnType<typeof AppStoreSubscriptionInfo.prototype.toObject>;
        promoInfo?: ReturnType<typeof PromoInfo.prototype.toObject>;
    }): AppStoreSubscriptions {
        const message = new AppStoreSubscriptions({});
        if (data.isTrialAvailable != null) {
            message.isTrialAvailable = data.isTrialAvailable;
        }
        if (data.monthly != null) {
            message.monthly = AppStoreSubscriptionInfo.fromObject(data.monthly);
        }
        if (data.annual != null) {
            message.annual = AppStoreSubscriptionInfo.fromObject(data.annual);
        }
        if (data.promoInfo != null) {
            message.promoInfo = PromoInfo.fromObject(data.promoInfo);
        }
        return message;
    }
    toObject() {
        const data: {
            isTrialAvailable?: boolean;
            monthly?: ReturnType<typeof AppStoreSubscriptionInfo.prototype.toObject>;
            annual?: ReturnType<typeof AppStoreSubscriptionInfo.prototype.toObject>;
            promoInfo?: ReturnType<typeof PromoInfo.prototype.toObject>;
        } = {};
        if (this.isTrialAvailable != null) {
            data.isTrialAvailable = this.isTrialAvailable;
        }
        if (this.monthly != null) {
            data.monthly = this.monthly.toObject();
        }
        if (this.annual != null) {
            data.annual = this.annual.toObject();
        }
        if (this.promoInfo != null) {
            data.promoInfo = this.promoInfo.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.isTrialAvailable != false)
            writer.writeBool(1, this.isTrialAvailable);
        if (this.has_monthly)
            writer.writeMessage(2, this.monthly, () => this.monthly.serialize(writer));
        if (this.has_annual)
            writer.writeMessage(3, this.annual, () => this.annual.serialize(writer));
        if (this.has_promoInfo)
            writer.writeMessage(4, this.promoInfo, () => this.promoInfo.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AppStoreSubscriptions {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AppStoreSubscriptions();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.isTrialAvailable = reader.readBool();
                    break;
                case 2:
                    reader.readMessage(message.monthly, () => message.monthly = AppStoreSubscriptionInfo.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.annual, () => message.annual = AppStoreSubscriptionInfo.deserialize(reader));
                    break;
                case 4:
                    reader.readMessage(message.promoInfo, () => message.promoInfo = PromoInfo.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AppStoreSubscriptions {
        return AppStoreSubscriptions.deserialize(bytes);
    }
}
export class AppStoreSubscriptionsMessage extends pb_1.Message {
    #one_of_decls: number[][] = [[2]];
    constructor(data?: any[] | ({
        error?: AppStoreSubscriptionsError;
    } & (({
        result?: AppStoreSubscriptions;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("error" in data && data.error != undefined) {
                this.error = data.error;
            }
            if ("result" in data && data.result != undefined) {
                this.result = data.result;
            }
        }
    }
    get error() {
        return pb_1.Message.getFieldWithDefault(this, 1, AppStoreSubscriptionsError.unknown) as AppStoreSubscriptionsError;
    }
    set error(value: AppStoreSubscriptionsError) {
        pb_1.Message.setField(this, 1, value);
    }
    get result() {
        return pb_1.Message.getWrapperField(this, AppStoreSubscriptions, 2) as AppStoreSubscriptions;
    }
    set result(value: AppStoreSubscriptions) {
        pb_1.Message.setOneofWrapperField(this, 2, this.#one_of_decls[0], value);
    }
    get has_result() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _result() {
        const cases: {
            [index: number]: "none" | "result";
        } = {
            0: "none",
            2: "result"
        };
        return cases[pb_1.Message.computeOneofCase(this, [2])];
    }
    static fromObject(data: {
        error?: AppStoreSubscriptionsError;
        result?: ReturnType<typeof AppStoreSubscriptions.prototype.toObject>;
    }): AppStoreSubscriptionsMessage {
        const message = new AppStoreSubscriptionsMessage({});
        if (data.error != null) {
            message.error = data.error;
        }
        if (data.result != null) {
            message.result = AppStoreSubscriptions.fromObject(data.result);
        }
        return message;
    }
    toObject() {
        const data: {
            error?: AppStoreSubscriptionsError;
            result?: ReturnType<typeof AppStoreSubscriptions.prototype.toObject>;
        } = {};
        if (this.error != null) {
            data.error = this.error;
        }
        if (this.result != null) {
            data.result = this.result.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.error != AppStoreSubscriptionsError.unknown)
            writer.writeEnum(1, this.error);
        if (this.has_result)
            writer.writeMessage(2, this.result, () => this.result.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): AppStoreSubscriptionsMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new AppStoreSubscriptionsMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.error = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.result, () => message.result = AppStoreSubscriptions.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): AppStoreSubscriptionsMessage {
        return AppStoreSubscriptionsMessage.deserialize(bytes);
    }
}
