/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 6.31.1
 * source: License.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./Helpers";
import * as pb_1 from "google-protobuf";
export enum LicenseStatus {
    unknown = 0,
    active = 1,
    trial = 2,
    free = 3,
    blocked_app_id = 4,
    expired = 5,
    uninstall = 6,
    wrong_key = 7,
    already_activate = 8,
    blocked = 9
}
export enum LicenseType {
    unknown = 0,
    personal = 1,
    family = 2,
    standard = 3,
    mobile = 4,
    premium = 5,
    beta = 6,
    bonus = 7
}
export enum SubscriptionStatus {
    unknown = 0,
    active = 1,
    past_due = 2,
    paused = 3,
    deleted = 4
}
export enum WebActivateResult {
    unknown = 0,
    cancelled = 1,
    user_redirected_to_purchase = 2,
    success = 3
}
export class LicenseOrError extends pb_1.Message {
    #one_of_decls: number[][] = [[1, 2]];
    constructor(data?: any[] | ({} & (({
        license?: License;
        error?: never;
    } | {
        license?: never;
        error?: boolean;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("license" in data && data.license != undefined) {
                this.license = data.license;
            }
            if ("error" in data && data.error != undefined) {
                this.error = data.error;
            }
        }
    }
    get license() {
        return pb_1.Message.getWrapperField(this, License, 1) as License;
    }
    set license(value: License) {
        pb_1.Message.setOneofWrapperField(this, 1, this.#one_of_decls[0], value);
    }
    get has_license() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get error() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set error(value: boolean) {
        pb_1.Message.setOneofField(this, 2, this.#one_of_decls[0], value);
    }
    get has_error() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get result() {
        const cases: {
            [index: number]: "none" | "license" | "error";
        } = {
            0: "none",
            1: "license",
            2: "error"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1, 2])];
    }
    static fromObject(data: {
        license?: ReturnType<typeof License.prototype.toObject>;
        error?: boolean;
    }): LicenseOrError {
        const message = new LicenseOrError({});
        if (data.license != null) {
            message.license = License.fromObject(data.license);
        }
        if (data.error != null) {
            message.error = data.error;
        }
        return message;
    }
    toObject() {
        const data: {
            license?: ReturnType<typeof License.prototype.toObject>;
            error?: boolean;
        } = {};
        if (this.license != null) {
            data.license = this.license.toObject();
        }
        if (this.error != null) {
            data.error = this.error;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_license)
            writer.writeMessage(1, this.license, () => this.license.serialize(writer));
        if (this.has_error)
            writer.writeBool(2, this.error);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): LicenseOrError {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new LicenseOrError();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.license, () => message.license = License.deserialize(reader));
                    break;
                case 2:
                    message.error = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): LicenseOrError {
        return LicenseOrError.deserialize(bytes);
    }
}
export class License extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        validUntil?: number;
        renewalDate?: number;
        licenseKey?: string;
        currentDevices?: number;
        totalDevices?: number;
        status?: LicenseStatus;
        type?: LicenseType;
        subscriptionStatus?: SubscriptionStatus;
        applicationKeyOwner?: string;
        licenseLifetime?: boolean;
        licenseTrial?: boolean;
        appStoreSubscription?: boolean;
        canReset?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("validUntil" in data && data.validUntil != undefined) {
                this.validUntil = data.validUntil;
            }
            if ("renewalDate" in data && data.renewalDate != undefined) {
                this.renewalDate = data.renewalDate;
            }
            if ("licenseKey" in data && data.licenseKey != undefined) {
                this.licenseKey = data.licenseKey;
            }
            if ("currentDevices" in data && data.currentDevices != undefined) {
                this.currentDevices = data.currentDevices;
            }
            if ("totalDevices" in data && data.totalDevices != undefined) {
                this.totalDevices = data.totalDevices;
            }
            if ("status" in data && data.status != undefined) {
                this.status = data.status;
            }
            if ("type" in data && data.type != undefined) {
                this.type = data.type;
            }
            if ("subscriptionStatus" in data && data.subscriptionStatus != undefined) {
                this.subscriptionStatus = data.subscriptionStatus;
            }
            if ("applicationKeyOwner" in data && data.applicationKeyOwner != undefined) {
                this.applicationKeyOwner = data.applicationKeyOwner;
            }
            if ("licenseLifetime" in data && data.licenseLifetime != undefined) {
                this.licenseLifetime = data.licenseLifetime;
            }
            if ("licenseTrial" in data && data.licenseTrial != undefined) {
                this.licenseTrial = data.licenseTrial;
            }
            if ("appStoreSubscription" in data && data.appStoreSubscription != undefined) {
                this.appStoreSubscription = data.appStoreSubscription;
            }
            if ("canReset" in data && data.canReset != undefined) {
                this.canReset = data.canReset;
            }
        }
    }
    get validUntil() {
        return pb_1.Message.getFieldWithDefault(this, 1, 0) as number;
    }
    set validUntil(value: number) {
        pb_1.Message.setField(this, 1, value);
    }
    get renewalDate() {
        return pb_1.Message.getFieldWithDefault(this, 2, 0) as number;
    }
    set renewalDate(value: number) {
        pb_1.Message.setField(this, 2, value);
    }
    get licenseKey() {
        return pb_1.Message.getFieldWithDefault(this, 3, "") as string;
    }
    set licenseKey(value: string) {
        pb_1.Message.setField(this, 3, value);
    }
    get currentDevices() {
        return pb_1.Message.getFieldWithDefault(this, 4, 0) as number;
    }
    set currentDevices(value: number) {
        pb_1.Message.setField(this, 4, value);
    }
    get totalDevices() {
        return pb_1.Message.getFieldWithDefault(this, 5, 0) as number;
    }
    set totalDevices(value: number) {
        pb_1.Message.setField(this, 5, value);
    }
    get status() {
        return pb_1.Message.getFieldWithDefault(this, 6, LicenseStatus.unknown) as LicenseStatus;
    }
    set status(value: LicenseStatus) {
        pb_1.Message.setField(this, 6, value);
    }
    get type() {
        return pb_1.Message.getFieldWithDefault(this, 7, LicenseType.unknown) as LicenseType;
    }
    set type(value: LicenseType) {
        pb_1.Message.setField(this, 7, value);
    }
    get subscriptionStatus() {
        return pb_1.Message.getFieldWithDefault(this, 8, SubscriptionStatus.unknown) as SubscriptionStatus;
    }
    set subscriptionStatus(value: SubscriptionStatus) {
        pb_1.Message.setField(this, 8, value);
    }
    get applicationKeyOwner() {
        return pb_1.Message.getFieldWithDefault(this, 9, "") as string;
    }
    set applicationKeyOwner(value: string) {
        pb_1.Message.setField(this, 9, value);
    }
    get licenseLifetime() {
        return pb_1.Message.getFieldWithDefault(this, 10, false) as boolean;
    }
    set licenseLifetime(value: boolean) {
        pb_1.Message.setField(this, 10, value);
    }
    get licenseTrial() {
        return pb_1.Message.getFieldWithDefault(this, 11, false) as boolean;
    }
    set licenseTrial(value: boolean) {
        pb_1.Message.setField(this, 11, value);
    }
    get appStoreSubscription() {
        return pb_1.Message.getFieldWithDefault(this, 12, false) as boolean;
    }
    set appStoreSubscription(value: boolean) {
        pb_1.Message.setField(this, 12, value);
    }
    get canReset() {
        return pb_1.Message.getFieldWithDefault(this, 13, false) as boolean;
    }
    set canReset(value: boolean) {
        pb_1.Message.setField(this, 13, value);
    }
    static fromObject(data: {
        validUntil?: number;
        renewalDate?: number;
        licenseKey?: string;
        currentDevices?: number;
        totalDevices?: number;
        status?: LicenseStatus;
        type?: LicenseType;
        subscriptionStatus?: SubscriptionStatus;
        applicationKeyOwner?: string;
        licenseLifetime?: boolean;
        licenseTrial?: boolean;
        appStoreSubscription?: boolean;
        canReset?: boolean;
    }): License {
        const message = new License({});
        if (data.validUntil != null) {
            message.validUntil = data.validUntil;
        }
        if (data.renewalDate != null) {
            message.renewalDate = data.renewalDate;
        }
        if (data.licenseKey != null) {
            message.licenseKey = data.licenseKey;
        }
        if (data.currentDevices != null) {
            message.currentDevices = data.currentDevices;
        }
        if (data.totalDevices != null) {
            message.totalDevices = data.totalDevices;
        }
        if (data.status != null) {
            message.status = data.status;
        }
        if (data.type != null) {
            message.type = data.type;
        }
        if (data.subscriptionStatus != null) {
            message.subscriptionStatus = data.subscriptionStatus;
        }
        if (data.applicationKeyOwner != null) {
            message.applicationKeyOwner = data.applicationKeyOwner;
        }
        if (data.licenseLifetime != null) {
            message.licenseLifetime = data.licenseLifetime;
        }
        if (data.licenseTrial != null) {
            message.licenseTrial = data.licenseTrial;
        }
        if (data.appStoreSubscription != null) {
            message.appStoreSubscription = data.appStoreSubscription;
        }
        if (data.canReset != null) {
            message.canReset = data.canReset;
        }
        return message;
    }
    toObject() {
        const data: {
            validUntil?: number;
            renewalDate?: number;
            licenseKey?: string;
            currentDevices?: number;
            totalDevices?: number;
            status?: LicenseStatus;
            type?: LicenseType;
            subscriptionStatus?: SubscriptionStatus;
            applicationKeyOwner?: string;
            licenseLifetime?: boolean;
            licenseTrial?: boolean;
            appStoreSubscription?: boolean;
            canReset?: boolean;
        } = {};
        if (this.validUntil != null) {
            data.validUntil = this.validUntil;
        }
        if (this.renewalDate != null) {
            data.renewalDate = this.renewalDate;
        }
        if (this.licenseKey != null) {
            data.licenseKey = this.licenseKey;
        }
        if (this.currentDevices != null) {
            data.currentDevices = this.currentDevices;
        }
        if (this.totalDevices != null) {
            data.totalDevices = this.totalDevices;
        }
        if (this.status != null) {
            data.status = this.status;
        }
        if (this.type != null) {
            data.type = this.type;
        }
        if (this.subscriptionStatus != null) {
            data.subscriptionStatus = this.subscriptionStatus;
        }
        if (this.applicationKeyOwner != null) {
            data.applicationKeyOwner = this.applicationKeyOwner;
        }
        if (this.licenseLifetime != null) {
            data.licenseLifetime = this.licenseLifetime;
        }
        if (this.licenseTrial != null) {
            data.licenseTrial = this.licenseTrial;
        }
        if (this.appStoreSubscription != null) {
            data.appStoreSubscription = this.appStoreSubscription;
        }
        if (this.canReset != null) {
            data.canReset = this.canReset;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.validUntil != 0)
            writer.writeInt64(1, this.validUntil);
        if (this.renewalDate != 0)
            writer.writeInt64(2, this.renewalDate);
        if (this.licenseKey.length)
            writer.writeString(3, this.licenseKey);
        if (this.currentDevices != 0)
            writer.writeInt32(4, this.currentDevices);
        if (this.totalDevices != 0)
            writer.writeInt32(5, this.totalDevices);
        if (this.status != LicenseStatus.unknown)
            writer.writeEnum(6, this.status);
        if (this.type != LicenseType.unknown)
            writer.writeEnum(7, this.type);
        if (this.subscriptionStatus != SubscriptionStatus.unknown)
            writer.writeEnum(8, this.subscriptionStatus);
        if (this.applicationKeyOwner.length)
            writer.writeString(9, this.applicationKeyOwner);
        if (this.licenseLifetime != false)
            writer.writeBool(10, this.licenseLifetime);
        if (this.licenseTrial != false)
            writer.writeBool(11, this.licenseTrial);
        if (this.appStoreSubscription != false)
            writer.writeBool(12, this.appStoreSubscription);
        if (this.canReset != false)
            writer.writeBool(13, this.canReset);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): License {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new License();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.validUntil = reader.readInt64();
                    break;
                case 2:
                    message.renewalDate = reader.readInt64();
                    break;
                case 3:
                    message.licenseKey = reader.readString();
                    break;
                case 4:
                    message.currentDevices = reader.readInt32();
                    break;
                case 5:
                    message.totalDevices = reader.readInt32();
                    break;
                case 6:
                    message.status = reader.readEnum();
                    break;
                case 7:
                    message.type = reader.readEnum();
                    break;
                case 8:
                    message.subscriptionStatus = reader.readEnum();
                    break;
                case 9:
                    message.applicationKeyOwner = reader.readString();
                    break;
                case 10:
                    message.licenseLifetime = reader.readBool();
                    break;
                case 11:
                    message.licenseTrial = reader.readBool();
                    break;
                case 12:
                    message.appStoreSubscription = reader.readBool();
                    break;
                case 13:
                    message.canReset = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): License {
        return License.deserialize(bytes);
    }
}
export class WebActivateResultMessage extends pb_1.Message {
    #one_of_decls: number[][] = [[1]];
    constructor(data?: any[] | ({
        error?: dependency_1.OptionalError;
    } & (({
        result?: WebActivateResult;
    })))) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("result" in data && data.result != undefined) {
                this.result = data.result;
            }
            if ("error" in data && data.error != undefined) {
                this.error = data.error;
            }
        }
    }
    get result() {
        return pb_1.Message.getFieldWithDefault(this, 1, WebActivateResult.unknown) as WebActivateResult;
    }
    set result(value: WebActivateResult) {
        pb_1.Message.setOneofField(this, 1, this.#one_of_decls[0], value);
    }
    get has_result() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get error() {
        return pb_1.Message.getWrapperField(this, dependency_1.OptionalError, 2) as dependency_1.OptionalError;
    }
    set error(value: dependency_1.OptionalError) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get has_error() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get _result() {
        const cases: {
            [index: number]: "none" | "result";
        } = {
            0: "none",
            1: "result"
        };
        return cases[pb_1.Message.computeOneofCase(this, [1])];
    }
    static fromObject(data: {
        result?: WebActivateResult;
        error?: ReturnType<typeof dependency_1.OptionalError.prototype.toObject>;
    }): WebActivateResultMessage {
        const message = new WebActivateResultMessage({});
        if (data.result != null) {
            message.result = data.result;
        }
        if (data.error != null) {
            message.error = dependency_1.OptionalError.fromObject(data.error);
        }
        return message;
    }
    toObject() {
        const data: {
            result?: WebActivateResult;
            error?: ReturnType<typeof dependency_1.OptionalError.prototype.toObject>;
        } = {};
        if (this.result != null) {
            data.result = this.result;
        }
        if (this.error != null) {
            data.error = this.error.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.has_result)
            writer.writeEnum(1, this.result);
        if (this.has_error)
            writer.writeMessage(2, this.error, () => this.error.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): WebActivateResultMessage {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new WebActivateResultMessage();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.result = reader.readEnum();
                    break;
                case 2:
                    reader.readMessage(message.error, () => message.error = dependency_1.OptionalError.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): WebActivateResultMessage {
        return WebActivateResultMessage.deserialize(bytes);
    }
}
