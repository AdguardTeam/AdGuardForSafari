// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Settings.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public enum ReleaseVariants: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case mas // = 1
  case standAlone // = 2
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .mas
    case 2: self = .standAlone
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .mas: return 1
    case .standAlone: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ReleaseVariants] = [
    .unknown,
    .mas,
    .standAlone,
  ]

}

public enum ImportMode: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case full // = 1
  case withoutAnnoyance // = 2
  case cancel // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .full
    case 2: self = .withoutAnnoyance
    case 3: self = .cancel
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .full: return 1
    case .withoutAnnoyance: return 2
    case .cancel: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [ImportMode] = [
    .unknown,
    .full,
    .withoutAnnoyance,
    .cancel,
  ]

}

public enum QuitReaction: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case ask // = 1
  case quit // = 2
  case keepRunning // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ask
    case 2: self = .quit
    case 3: self = .keepRunning
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ask: return 1
    case .quit: return 2
    case .keepRunning: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [QuitReaction] = [
    .unknown,
    .ask,
    .quit,
    .keepRunning,
  ]

}

public enum SafariExtensionType: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case general // = 0
  case privacy // = 1
  case security // = 2
  case social // = 3
  case other // = 4
  case custom // = 5
  case adguardForSafari // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .general
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .general
    case 1: self = .privacy
    case 2: self = .security
    case 3: self = .social
    case 4: self = .other
    case 5: self = .custom
    case 6: self = .adguardForSafari
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .general: return 0
    case .privacy: return 1
    case .security: return 2
    case .social: return 3
    case .other: return 4
    case .custom: return 5
    case .adguardForSafari: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SafariExtensionType] = [
    .general,
    .privacy,
    .security,
    .social,
    .other,
    .custom,
    .adguardForSafari,
  ]

}

public enum SafariExtensionStatus: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case ok // = 1
  case loading // = 2
  case disabled // = 3
  case limitExceeded // = 4
  case converterError // = 5
  case safariError // = 6
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .ok
    case 2: self = .loading
    case 3: self = .disabled
    case 4: self = .limitExceeded
    case 5: self = .converterError
    case 6: self = .safariError
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .ok: return 1
    case .loading: return 2
    case .disabled: return 3
    case .limitExceeded: return 4
    case .converterError: return 5
    case .safariError: return 6
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [SafariExtensionStatus] = [
    .unknown,
    .ok,
    .loading,
    .disabled,
    .limitExceeded,
    .converterError,
    .safariError,
  ]

}

public enum Theme: SwiftProtobuf.Enum, Swift.CaseIterable {
  public typealias RawValue = Int
  case unknown // = 0
  case system // = 1
  case light // = 2
  case dark // = 3
  case UNRECOGNIZED(Int)

  public init() {
    self = .unknown
  }

  public init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .unknown
    case 1: self = .system
    case 2: self = .light
    case 3: self = .dark
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  public var rawValue: Int {
    switch self {
    case .unknown: return 0
    case .system: return 1
    case .light: return 2
    case .dark: return 3
    case .UNRECOGNIZED(let i): return i
    }
  }

  // The compiler won't synthesize support with the UNRECOGNIZED case.
  public static let allCases: [Theme] = [
    .unknown,
    .system,
    .light,
    .dark,
  ]

}

/// Describes settings page
public struct Settings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var launchOnStartup: Bool = false

  public var showInMenuBar: Bool = false

  public var hardwareAcceleration: Bool = false

  public var autoFiltersUpdate: Bool = false

  public var realTimeFiltersUpdate: Bool = false

  public var quitReaction: QuitReaction = .unknown

  public var debugLogging: Bool = false

  public var releaseVariant: ReleaseVariants = .unknown

  public var consentFiltersIds: [Int32] = []

  public var language: String = String()

  public var theme: Theme = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UserConsent: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filtersIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImportSettingsConfirmation: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var mode: ImportMode = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct ImportStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var success: Bool = false

  public var filtersIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct GlobalSettings: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var enabled: Bool = false

  public var allExtensionEnabled: Bool = false

  public var newVersionAvailable: Bool = false

  public var releaseVariant: ReleaseVariants = .unknown

  public var language: String = String()

  public var debugLogging: Bool = false

  public var recentlyMigrated: Bool = false

  public var theme: Theme = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct UpdateQuitReactionMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var reaction: QuitReaction = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct SafariExtensions: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var general: SafariExtension {
    get {return _storage._general ?? SafariExtension()}
    set {_uniqueStorage()._general = newValue}
  }
  /// Returns true if `general` has been explicitly set.
  public var hasGeneral: Bool {return _storage._general != nil}
  /// Clears the value of `general`. Subsequent reads from it will return its default value.
  public mutating func clearGeneral() {_uniqueStorage()._general = nil}

  public var privacy: SafariExtension {
    get {return _storage._privacy ?? SafariExtension()}
    set {_uniqueStorage()._privacy = newValue}
  }
  /// Returns true if `privacy` has been explicitly set.
  public var hasPrivacy: Bool {return _storage._privacy != nil}
  /// Clears the value of `privacy`. Subsequent reads from it will return its default value.
  public mutating func clearPrivacy() {_uniqueStorage()._privacy = nil}

  public var social: SafariExtension {
    get {return _storage._social ?? SafariExtension()}
    set {_uniqueStorage()._social = newValue}
  }
  /// Returns true if `social` has been explicitly set.
  public var hasSocial: Bool {return _storage._social != nil}
  /// Clears the value of `social`. Subsequent reads from it will return its default value.
  public mutating func clearSocial() {_uniqueStorage()._social = nil}

  public var security: SafariExtension {
    get {return _storage._security ?? SafariExtension()}
    set {_uniqueStorage()._security = newValue}
  }
  /// Returns true if `security` has been explicitly set.
  public var hasSecurity: Bool {return _storage._security != nil}
  /// Clears the value of `security`. Subsequent reads from it will return its default value.
  public mutating func clearSecurity() {_uniqueStorage()._security = nil}

  public var other: SafariExtension {
    get {return _storage._other ?? SafariExtension()}
    set {_uniqueStorage()._other = newValue}
  }
  /// Returns true if `other` has been explicitly set.
  public var hasOther: Bool {return _storage._other != nil}
  /// Clears the value of `other`. Subsequent reads from it will return its default value.
  public mutating func clearOther() {_uniqueStorage()._other = nil}

  public var custom: SafariExtension {
    get {return _storage._custom ?? SafariExtension()}
    set {_uniqueStorage()._custom = newValue}
  }
  /// Returns true if `custom` has been explicitly set.
  public var hasCustom: Bool {return _storage._custom != nil}
  /// Clears the value of `custom`. Subsequent reads from it will return its default value.
  public mutating func clearCustom() {_uniqueStorage()._custom = nil}

  public var adguardForSafari: SafariExtension {
    get {return _storage._adguardForSafari ?? SafariExtension()}
    set {_uniqueStorage()._adguardForSafari = newValue}
  }
  /// Returns true if `adguardForSafari` has been explicitly set.
  public var hasAdguardForSafari: Bool {return _storage._adguardForSafari != nil}
  /// Clears the value of `adguardForSafari`. Subsequent reads from it will return its default value.
  public mutating func clearAdguardForSafari() {_uniqueStorage()._adguardForSafari = nil}

  public var allExtensionsEnabled: Bool {
    get {return _storage._allExtensionsEnabled}
    set {_uniqueStorage()._allExtensionsEnabled = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct SafariExtension: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: String = String()

  public var rulesEnabled: Int32 = 0

  public var rulesTotal: Int32 = 0

  public var status: SafariExtensionStatus = .unknown

  public var safariError: String {
    get {return _safariError ?? String()}
    set {_safariError = newValue}
  }
  /// Returns true if `safariError` has been explicitly set.
  public var hasSafariError: Bool {return self._safariError != nil}
  /// Clears the value of `safariError`. Subsequent reads from it will return its default value.
  public mutating func clearSafariError() {self._safariError = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _safariError: String? = nil
}

public struct SafariExtensionUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var type: SafariExtensionType = .general

  public var state: SafariExtension {
    get {return _state ?? SafariExtension()}
    set {_state = newValue}
  }
  /// Returns true if `state` has been explicitly set.
  public var hasState: Bool {return self._state != nil}
  /// Clears the value of `state`. Subsequent reads from it will return its default value.
  public mutating func clearState() {self._state = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _state: SafariExtension? = nil
}

public struct UpdateThemeMessage: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var theme: Theme = .unknown

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension ReleaseVariants: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ReleaseVariants_unknown\0\u{1}ReleaseVariants_MAS\0\u{1}ReleaseVariants_standAlone\0")
}

extension ImportMode: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0ImportMode_unknown\0\u{1}ImportMode_full\0\u{1}ImportMode_withoutAnnoyance\0\u{1}ImportMode_cancel\0")
}

extension QuitReaction: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0QuitReaction_unknown\0\u{1}QuitReaction_ask\0\u{1}QuitReaction_quit\0\u{1}QuitReaction_keepRunning\0")
}

extension SafariExtensionType: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SafariExtensionType_general\0\u{1}SafariExtensionType_privacy\0\u{1}SafariExtensionType_security\0\u{1}SafariExtensionType_social\0\u{1}SafariExtensionType_other\0\u{1}SafariExtensionType_custom\0\u{1}SafariExtensionType_adguard_for_safari\0")
}

extension SafariExtensionStatus: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0SafariExtensionStatus_unknown\0\u{1}SafariExtensionStatus_ok\0\u{1}SafariExtensionStatus_loading\0\u{1}SafariExtensionStatus_disabled\0\u{1}SafariExtensionStatus_limit_exceeded\0\u{1}SafariExtensionStatus_converter_error\0\u{1}SafariExtensionStatus_safari_error\0")
}

extension Theme: SwiftProtobuf._ProtoNameProviding {
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{2}\0Theme_unknown\0\u{1}Theme_system\0\u{1}Theme_light\0\u{1}Theme_dark\0")
}

extension Settings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Settings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}launch_on_startup\0\u{3}show_in_menu_bar\0\u{3}hardware_acceleration\0\u{3}auto_filters_update\0\u{3}real_time_filters_update\0\u{1}quitReaction\0\u{3}debug_logging\0\u{3}release_variant\0\u{3}consent_filters_ids\0\u{1}language\0\u{1}theme\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.launchOnStartup) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.showInMenuBar) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.hardwareAcceleration) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.autoFiltersUpdate) }()
      case 5: try { try decoder.decodeSingularBoolField(value: &self.realTimeFiltersUpdate) }()
      case 6: try { try decoder.decodeSingularEnumField(value: &self.quitReaction) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.debugLogging) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.releaseVariant) }()
      case 9: try { try decoder.decodeRepeatedInt32Field(value: &self.consentFiltersIds) }()
      case 10: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 11: try { try decoder.decodeSingularEnumField(value: &self.theme) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.launchOnStartup != false {
      try visitor.visitSingularBoolField(value: self.launchOnStartup, fieldNumber: 1)
    }
    if self.showInMenuBar != false {
      try visitor.visitSingularBoolField(value: self.showInMenuBar, fieldNumber: 2)
    }
    if self.hardwareAcceleration != false {
      try visitor.visitSingularBoolField(value: self.hardwareAcceleration, fieldNumber: 3)
    }
    if self.autoFiltersUpdate != false {
      try visitor.visitSingularBoolField(value: self.autoFiltersUpdate, fieldNumber: 4)
    }
    if self.realTimeFiltersUpdate != false {
      try visitor.visitSingularBoolField(value: self.realTimeFiltersUpdate, fieldNumber: 5)
    }
    if self.quitReaction != .unknown {
      try visitor.visitSingularEnumField(value: self.quitReaction, fieldNumber: 6)
    }
    if self.debugLogging != false {
      try visitor.visitSingularBoolField(value: self.debugLogging, fieldNumber: 7)
    }
    if self.releaseVariant != .unknown {
      try visitor.visitSingularEnumField(value: self.releaseVariant, fieldNumber: 8)
    }
    if !self.consentFiltersIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.consentFiltersIds, fieldNumber: 9)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 10)
    }
    if self.theme != .unknown {
      try visitor.visitSingularEnumField(value: self.theme, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Settings, rhs: Settings) -> Bool {
    if lhs.launchOnStartup != rhs.launchOnStartup {return false}
    if lhs.showInMenuBar != rhs.showInMenuBar {return false}
    if lhs.hardwareAcceleration != rhs.hardwareAcceleration {return false}
    if lhs.autoFiltersUpdate != rhs.autoFiltersUpdate {return false}
    if lhs.realTimeFiltersUpdate != rhs.realTimeFiltersUpdate {return false}
    if lhs.quitReaction != rhs.quitReaction {return false}
    if lhs.debugLogging != rhs.debugLogging {return false}
    if lhs.releaseVariant != rhs.releaseVariant {return false}
    if lhs.consentFiltersIds != rhs.consentFiltersIds {return false}
    if lhs.language != rhs.language {return false}
    if lhs.theme != rhs.theme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UserConsent: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UserConsent"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{3}filters_ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.filtersIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filtersIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.filtersIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UserConsent, rhs: UserConsent) -> Bool {
    if lhs.filtersIds != rhs.filtersIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImportSettingsConfirmation: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImportSettingsConfirmation"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}mode\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.mode) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.mode != .unknown {
      try visitor.visitSingularEnumField(value: self.mode, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImportSettingsConfirmation, rhs: ImportSettingsConfirmation) -> Bool {
    if lhs.mode != rhs.mode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ImportStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "ImportStatus"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}success\0\u{3}filters_ids\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.filtersIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    if !self.filtersIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.filtersIds, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: ImportStatus, rhs: ImportStatus) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.filtersIds != rhs.filtersIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension GlobalSettings: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "GlobalSettings"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}enabled\0\u{1}allExtensionEnabled\0\u{1}newVersionAvailable\0\u{1}releaseVariant\0\u{1}language\0\u{3}debug_logging\0\u{3}recently_migrated\0\u{1}theme\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.allExtensionEnabled) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.newVersionAvailable) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.releaseVariant) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.language) }()
      case 6: try { try decoder.decodeSingularBoolField(value: &self.debugLogging) }()
      case 7: try { try decoder.decodeSingularBoolField(value: &self.recentlyMigrated) }()
      case 8: try { try decoder.decodeSingularEnumField(value: &self.theme) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 1)
    }
    if self.allExtensionEnabled != false {
      try visitor.visitSingularBoolField(value: self.allExtensionEnabled, fieldNumber: 2)
    }
    if self.newVersionAvailable != false {
      try visitor.visitSingularBoolField(value: self.newVersionAvailable, fieldNumber: 3)
    }
    if self.releaseVariant != .unknown {
      try visitor.visitSingularEnumField(value: self.releaseVariant, fieldNumber: 4)
    }
    if !self.language.isEmpty {
      try visitor.visitSingularStringField(value: self.language, fieldNumber: 5)
    }
    if self.debugLogging != false {
      try visitor.visitSingularBoolField(value: self.debugLogging, fieldNumber: 6)
    }
    if self.recentlyMigrated != false {
      try visitor.visitSingularBoolField(value: self.recentlyMigrated, fieldNumber: 7)
    }
    if self.theme != .unknown {
      try visitor.visitSingularEnumField(value: self.theme, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: GlobalSettings, rhs: GlobalSettings) -> Bool {
    if lhs.enabled != rhs.enabled {return false}
    if lhs.allExtensionEnabled != rhs.allExtensionEnabled {return false}
    if lhs.newVersionAvailable != rhs.newVersionAvailable {return false}
    if lhs.releaseVariant != rhs.releaseVariant {return false}
    if lhs.language != rhs.language {return false}
    if lhs.debugLogging != rhs.debugLogging {return false}
    if lhs.recentlyMigrated != rhs.recentlyMigrated {return false}
    if lhs.theme != rhs.theme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateQuitReactionMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateQuitReactionMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}reaction\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.reaction) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.reaction != .unknown {
      try visitor.visitSingularEnumField(value: self.reaction, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateQuitReactionMessage, rhs: UpdateQuitReactionMessage) -> Bool {
    if lhs.reaction != rhs.reaction {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SafariExtensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SafariExtensions"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}general\0\u{1}privacy\0\u{1}social\0\u{1}security\0\u{1}other\0\u{1}custom\0\u{3}adguard_for_safari\0\u{3}all_extensions_enabled\0")

  fileprivate class _StorageClass {
    var _general: SafariExtension? = nil
    var _privacy: SafariExtension? = nil
    var _social: SafariExtension? = nil
    var _security: SafariExtension? = nil
    var _other: SafariExtension? = nil
    var _custom: SafariExtension? = nil
    var _adguardForSafari: SafariExtension? = nil
    var _allExtensionsEnabled: Bool = false

      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _general = source._general
      _privacy = source._privacy
      _social = source._social
      _security = source._security
      _other = source._other
      _custom = source._custom
      _adguardForSafari = source._adguardForSafari
      _allExtensionsEnabled = source._allExtensionsEnabled
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularMessageField(value: &_storage._general) }()
        case 2: try { try decoder.decodeSingularMessageField(value: &_storage._privacy) }()
        case 3: try { try decoder.decodeSingularMessageField(value: &_storage._social) }()
        case 4: try { try decoder.decodeSingularMessageField(value: &_storage._security) }()
        case 5: try { try decoder.decodeSingularMessageField(value: &_storage._other) }()
        case 6: try { try decoder.decodeSingularMessageField(value: &_storage._custom) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._adguardForSafari) }()
        case 8: try { try decoder.decodeSingularBoolField(value: &_storage._allExtensionsEnabled) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      try { if let v = _storage._general {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      } }()
      try { if let v = _storage._privacy {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      } }()
      try { if let v = _storage._social {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      } }()
      try { if let v = _storage._security {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      } }()
      try { if let v = _storage._other {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      } }()
      try { if let v = _storage._custom {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      } }()
      try { if let v = _storage._adguardForSafari {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if _storage._allExtensionsEnabled != false {
        try visitor.visitSingularBoolField(value: _storage._allExtensionsEnabled, fieldNumber: 8)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SafariExtensions, rhs: SafariExtensions) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._general != rhs_storage._general {return false}
        if _storage._privacy != rhs_storage._privacy {return false}
        if _storage._social != rhs_storage._social {return false}
        if _storage._security != rhs_storage._security {return false}
        if _storage._other != rhs_storage._other {return false}
        if _storage._custom != rhs_storage._custom {return false}
        if _storage._adguardForSafari != rhs_storage._adguardForSafari {return false}
        if _storage._allExtensionsEnabled != rhs_storage._allExtensionsEnabled {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SafariExtension: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SafariExtension"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}id\0\u{3}rules_enabled\0\u{3}rules_total\0\u{1}status\0\u{4}\u{2}safari_error\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.rulesEnabled) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.rulesTotal) }()
      case 4: try { try decoder.decodeSingularEnumField(value: &self.status) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self._safariError) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if self.rulesEnabled != 0 {
      try visitor.visitSingularInt32Field(value: self.rulesEnabled, fieldNumber: 2)
    }
    if self.rulesTotal != 0 {
      try visitor.visitSingularInt32Field(value: self.rulesTotal, fieldNumber: 3)
    }
    if self.status != .unknown {
      try visitor.visitSingularEnumField(value: self.status, fieldNumber: 4)
    }
    try { if let v = self._safariError {
      try visitor.visitSingularStringField(value: v, fieldNumber: 6)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SafariExtension, rhs: SafariExtension) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.rulesEnabled != rhs.rulesEnabled {return false}
    if lhs.rulesTotal != rhs.rulesTotal {return false}
    if lhs.status != rhs.status {return false}
    if lhs._safariError != rhs._safariError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension SafariExtensionUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "SafariExtensionUpdate"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}type\0\u{1}state\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.type) }()
      case 2: try { try decoder.decodeSingularMessageField(value: &self._state) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.type != .general {
      try visitor.visitSingularEnumField(value: self.type, fieldNumber: 1)
    }
    try { if let v = self._state {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: SafariExtensionUpdate, rhs: SafariExtensionUpdate) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs._state != rhs._state {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension UpdateThemeMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "UpdateThemeMessage"
  public static let _protobuf_nameMap = SwiftProtobuf._NameMap(bytecode: "\0\u{1}theme\0")

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularEnumField(value: &self.theme) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.theme != .unknown {
      try visitor.visitSingularEnumField(value: self.theme, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: UpdateThemeMessage, rhs: UpdateThemeMessage) -> Bool {
    if lhs.theme != rhs.theme {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
