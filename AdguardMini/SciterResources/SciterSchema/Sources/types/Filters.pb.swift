// DO NOT EDIT.
// swift-format-ignore-file
// swiftlint:disable all
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: Filters.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes the structure of filters
public struct Filters: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filters: [Filter] = []

  public var preferredLocales: [String] = []

  public var customFilters: [Filter] = []

  public var languageSpecific: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Structure for filter groups
public struct FilterGroup: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var groupID: Int32 = 0

  public var groupName: String = String()

  public var displayNumber: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersUpdate: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Int32] = []

  public var isEnabled: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersEnabledIds: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Filter entity
public struct Filter: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var groupID: Int32 = 0

  public var enabled: Bool = false

  public var timeUpdated: Int64 = 0

  public var title: String = String()

  public var description_p: String = String()

  public var version: String = String()

  public var homepage: String = String()

  public var rulesCount: Int32 = 0

  public var languages: [String] = []

  public var trusted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterOrError: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterOrError: FilterOrError.OneOf_FilterOrError? = nil

  public var filter: Filter {
    get {
      if case .filter(let v)? = filterOrError {return v}
      return Filter()
    }
    set {filterOrError = .filter(newValue)}
  }

  public var error: Bool {
    get {
      if case .error(let v)? = filterOrError {return v}
      return false
    }
    set {filterOrError = .error(newValue)}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public enum OneOf_FilterOrError: Equatable, Sendable {
    case filter(Filter)
    case error(Bool)

  }

  public init() {}
}

public struct CustomFilterToAdd: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var url: String = String()

  public var title: String = String()

  public var trusted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CustomFiltersToDelete: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filtersIds: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersDefinedGroups: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var adBlocking: Int32 = 0

  public var privacy: Int32 = 0

  public var socialWidgets: Int32 = 0

  public var annoyances: Int32 = 0

  public var security: Int32 = 0

  public var other: Int32 = 0

  public var languageSpecific: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersIds: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var ids: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersIndex: @unchecked Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var unblockSearchAdsFilterID: Int32 {
    get {return _storage._unblockSearchAdsFilterID}
    set {_uniqueStorage()._unblockSearchAdsFilterID = newValue}
  }

  public var cookieNoticeFilterID: Int32 {
    get {return _storage._cookieNoticeFilterID}
    set {_uniqueStorage()._cookieNoticeFilterID = newValue}
  }

  public var popUpsFilterID: Int32 {
    get {return _storage._popUpsFilterID}
    set {_uniqueStorage()._popUpsFilterID = newValue}
  }

  public var widgetsFilterID: Int32 {
    get {return _storage._widgetsFilterID}
    set {_uniqueStorage()._widgetsFilterID = newValue}
  }

  public var otherAnnoyanceFilterID: Int32 {
    get {return _storage._otherAnnoyanceFilterID}
    set {_uniqueStorage()._otherAnnoyanceFilterID = newValue}
  }

  public var mobileBannersFilter: Int32 {
    get {return _storage._mobileBannersFilter}
    set {_uniqueStorage()._mobileBannersFilter = newValue}
  }

  public var definedGroups: FiltersDefinedGroups {
    get {return _storage._definedGroups ?? FiltersDefinedGroups()}
    set {_uniqueStorage()._definedGroups = newValue}
  }
  /// Returns true if `definedGroups` has been explicitly set.
  public var hasDefinedGroups: Bool {return _storage._definedGroups != nil}
  /// Clears the value of `definedGroups`. Subsequent reads from it will return its default value.
  public mutating func clearDefinedGroups() {_uniqueStorage()._definedGroups = nil}

  public var groups: [FilterGroup] {
    get {return _storage._groups}
    set {_uniqueStorage()._groups = newValue}
  }

  public var filtersByGroups: Dictionary<Int32,FiltersIds> {
    get {return _storage._filtersByGroups}
    set {_uniqueStorage()._filtersByGroups = newValue}
  }

  public var recommendedFiltersIdsByGroupDict: Dictionary<Int32,FiltersIds> {
    get {return _storage._recommendedFiltersIdsByGroupDict}
    set {_uniqueStorage()._recommendedFiltersIdsByGroupDict = newValue}
  }

  public var otherFiltersIdsByGroupDict: Dictionary<Int32,FiltersIds> {
    get {return _storage._otherFiltersIdsByGroupDict}
    set {_uniqueStorage()._otherFiltersIdsByGroupDict = newValue}
  }

  public var customGroupID: Int32 {
    get {return _storage._customGroupID}
    set {_uniqueStorage()._customGroupID = newValue}
  }

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct FiltersGroupedByExtensions: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var general: [Int32] = []

  public var privacy: [Int32] = []

  public var social: [Int32] = []

  public var security: [Int32] = []

  public var other: [Int32] = []

  public var custom: [Int32] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct CustomFilterUpdateRequest: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var filterID: Int32 = 0

  public var title: String = String()

  public var isTrusted: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FiltersStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var status: [FilterUpdateStatus] = []

  public var error: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct FilterUpdateStatus: Sendable {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var id: Int32 = 0

  public var version: String {
    get {return _version ?? String()}
    set {_version = newValue}
  }
  /// Returns true if `version` has been explicitly set.
  public var hasVersion: Bool {return self._version != nil}
  /// Clears the value of `version`. Subsequent reads from it will return its default value.
  public mutating func clearVersion() {self._version = nil}

  public var success: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _version: String? = nil
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension Filters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Filters"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters"),
    2: .same(proto: "preferredLocales"),
    3: .same(proto: "customFilters"),
    4: .same(proto: "languageSpecific"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.filters) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.preferredLocales) }()
      case 3: try { try decoder.decodeRepeatedMessageField(value: &self.customFilters) }()
      case 4: try { try decoder.decodeSingularBoolField(value: &self.languageSpecific) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.filters, fieldNumber: 1)
    }
    if !self.preferredLocales.isEmpty {
      try visitor.visitRepeatedStringField(value: self.preferredLocales, fieldNumber: 2)
    }
    if !self.customFilters.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.customFilters, fieldNumber: 3)
    }
    if self.languageSpecific != false {
      try visitor.visitSingularBoolField(value: self.languageSpecific, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Filters, rhs: Filters) -> Bool {
    if lhs.filters != rhs.filters {return false}
    if lhs.preferredLocales != rhs.preferredLocales {return false}
    if lhs.customFilters != rhs.customFilters {return false}
    if lhs.languageSpecific != rhs.languageSpecific {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterGroup: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FilterGroup"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "groupId"),
    2: .same(proto: "groupName"),
    3: .same(proto: "displayNumber"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.groupName) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.displayNumber) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 1)
    }
    if !self.groupName.isEmpty {
      try visitor.visitSingularStringField(value: self.groupName, fieldNumber: 2)
    }
    if self.displayNumber != 0 {
      try visitor.visitSingularInt32Field(value: self.displayNumber, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterGroup, rhs: FilterGroup) -> Bool {
    if lhs.groupID != rhs.groupID {return false}
    if lhs.groupName != rhs.groupName {return false}
    if lhs.displayNumber != rhs.displayNumber {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersUpdate: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersUpdate"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
    2: .same(proto: "isEnabled"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.ids) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.isEnabled) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitPackedInt32Field(value: self.ids, fieldNumber: 1)
    }
    if self.isEnabled != false {
      try visitor.visitSingularBoolField(value: self.isEnabled, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersUpdate, rhs: FiltersUpdate) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.isEnabled != rhs.isEnabled {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersEnabledIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersEnabledIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitPackedInt32Field(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersEnabledIds, rhs: FiltersEnabledIds) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Filter: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "Filter"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "group_id"),
    3: .same(proto: "enabled"),
    4: .standard(proto: "time_updated"),
    5: .same(proto: "title"),
    6: .same(proto: "description"),
    7: .same(proto: "version"),
    8: .same(proto: "homepage"),
    9: .standard(proto: "rules_count"),
    10: .same(proto: "languages"),
    11: .same(proto: "trusted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.groupID) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.enabled) }()
      case 4: try { try decoder.decodeSingularInt64Field(value: &self.timeUpdated) }()
      case 5: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 6: try { try decoder.decodeSingularStringField(value: &self.description_p) }()
      case 7: try { try decoder.decodeSingularStringField(value: &self.version) }()
      case 8: try { try decoder.decodeSingularStringField(value: &self.homepage) }()
      case 9: try { try decoder.decodeSingularInt32Field(value: &self.rulesCount) }()
      case 10: try { try decoder.decodeRepeatedStringField(value: &self.languages) }()
      case 11: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    if self.groupID != 0 {
      try visitor.visitSingularInt32Field(value: self.groupID, fieldNumber: 2)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 3)
    }
    if self.timeUpdated != 0 {
      try visitor.visitSingularInt64Field(value: self.timeUpdated, fieldNumber: 4)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 5)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 6)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 7)
    }
    if !self.homepage.isEmpty {
      try visitor.visitSingularStringField(value: self.homepage, fieldNumber: 8)
    }
    if self.rulesCount != 0 {
      try visitor.visitSingularInt32Field(value: self.rulesCount, fieldNumber: 9)
    }
    if !self.languages.isEmpty {
      try visitor.visitRepeatedStringField(value: self.languages, fieldNumber: 10)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Filter, rhs: Filter) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.groupID != rhs.groupID {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.timeUpdated != rhs.timeUpdated {return false}
    if lhs.title != rhs.title {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.version != rhs.version {return false}
    if lhs.homepage != rhs.homepage {return false}
    if lhs.rulesCount != rhs.rulesCount {return false}
    if lhs.languages != rhs.languages {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterOrError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FilterOrError"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filter"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try {
        var v: Filter?
        var hadOneofValue = false
        if let current = self.filterOrError {
          hadOneofValue = true
          if case .filter(let m) = current {v = m}
        }
        try decoder.decodeSingularMessageField(value: &v)
        if let v = v {
          if hadOneofValue {try decoder.handleConflictingOneOf()}
          self.filterOrError = .filter(v)
        }
      }()
      case 2: try {
        var v: Bool?
        try decoder.decodeSingularBoolField(value: &v)
        if let v = v {
          if self.filterOrError != nil {try decoder.handleConflictingOneOf()}
          self.filterOrError = .error(v)
        }
      }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    switch self.filterOrError {
    case .filter?: try {
      guard case .filter(let v)? = self.filterOrError else { preconditionFailure() }
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    }()
    case .error?: try {
      guard case .error(let v)? = self.filterOrError else { preconditionFailure() }
      try visitor.visitSingularBoolField(value: v, fieldNumber: 2)
    }()
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterOrError, rhs: FilterOrError) -> Bool {
    if lhs.filterOrError != rhs.filterOrError {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomFilterToAdd: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CustomFilterToAdd"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "url"),
    2: .same(proto: "title"),
    3: .same(proto: "trusted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.url) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.trusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.url.isEmpty {
      try visitor.visitSingularStringField(value: self.url, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.trusted != false {
      try visitor.visitSingularBoolField(value: self.trusted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomFilterToAdd, rhs: CustomFilterToAdd) -> Bool {
    if lhs.url != rhs.url {return false}
    if lhs.title != rhs.title {return false}
    if lhs.trusted != rhs.trusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomFiltersToDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CustomFiltersToDelete"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filtersIds"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.filtersIds) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.filtersIds.isEmpty {
      try visitor.visitPackedInt32Field(value: self.filtersIds, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomFiltersToDelete, rhs: CustomFiltersToDelete) -> Bool {
    if lhs.filtersIds != rhs.filtersIds {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersDefinedGroups: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersDefinedGroups"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "adBlocking"),
    2: .same(proto: "privacy"),
    3: .same(proto: "socialWidgets"),
    4: .same(proto: "annoyances"),
    5: .same(proto: "security"),
    6: .same(proto: "other"),
    7: .same(proto: "languageSpecific"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.adBlocking) }()
      case 2: try { try decoder.decodeSingularInt32Field(value: &self.privacy) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.socialWidgets) }()
      case 4: try { try decoder.decodeSingularInt32Field(value: &self.annoyances) }()
      case 5: try { try decoder.decodeSingularInt32Field(value: &self.security) }()
      case 6: try { try decoder.decodeSingularInt32Field(value: &self.other) }()
      case 7: try { try decoder.decodeSingularInt32Field(value: &self.languageSpecific) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.adBlocking != 0 {
      try visitor.visitSingularInt32Field(value: self.adBlocking, fieldNumber: 1)
    }
    if self.privacy != 0 {
      try visitor.visitSingularInt32Field(value: self.privacy, fieldNumber: 2)
    }
    if self.socialWidgets != 0 {
      try visitor.visitSingularInt32Field(value: self.socialWidgets, fieldNumber: 3)
    }
    if self.annoyances != 0 {
      try visitor.visitSingularInt32Field(value: self.annoyances, fieldNumber: 4)
    }
    if self.security != 0 {
      try visitor.visitSingularInt32Field(value: self.security, fieldNumber: 5)
    }
    if self.other != 0 {
      try visitor.visitSingularInt32Field(value: self.other, fieldNumber: 6)
    }
    if self.languageSpecific != 0 {
      try visitor.visitSingularInt32Field(value: self.languageSpecific, fieldNumber: 7)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersDefinedGroups, rhs: FiltersDefinedGroups) -> Bool {
    if lhs.adBlocking != rhs.adBlocking {return false}
    if lhs.privacy != rhs.privacy {return false}
    if lhs.socialWidgets != rhs.socialWidgets {return false}
    if lhs.annoyances != rhs.annoyances {return false}
    if lhs.security != rhs.security {return false}
    if lhs.other != rhs.other {return false}
    if lhs.languageSpecific != rhs.languageSpecific {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersIds: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersIds"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "ids"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.ids) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.ids.isEmpty {
      try visitor.visitPackedInt32Field(value: self.ids, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersIds, rhs: FiltersIds) -> Bool {
    if lhs.ids != rhs.ids {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersIndex: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersIndex"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "unblockSearchAdsFilterId"),
    2: .same(proto: "cookieNoticeFilterId"),
    3: .same(proto: "popUpsFilterId"),
    4: .same(proto: "widgetsFilterId"),
    5: .same(proto: "otherAnnoyanceFilterId"),
    6: .same(proto: "mobileBannersFilter"),
    7: .same(proto: "definedGroups"),
    8: .same(proto: "groups"),
    9: .same(proto: "filtersByGroups"),
    10: .same(proto: "recommendedFiltersIdsByGroupDict"),
    11: .same(proto: "otherFiltersIdsByGroupDict"),
    12: .same(proto: "customGroupId"),
  ]

  fileprivate class _StorageClass {
    var _unblockSearchAdsFilterID: Int32 = 0
    var _cookieNoticeFilterID: Int32 = 0
    var _popUpsFilterID: Int32 = 0
    var _widgetsFilterID: Int32 = 0
    var _otherAnnoyanceFilterID: Int32 = 0
    var _mobileBannersFilter: Int32 = 0
    var _definedGroups: FiltersDefinedGroups? = nil
    var _groups: [FilterGroup] = []
    var _filtersByGroups: Dictionary<Int32,FiltersIds> = [:]
    var _recommendedFiltersIdsByGroupDict: Dictionary<Int32,FiltersIds> = [:]
    var _otherFiltersIdsByGroupDict: Dictionary<Int32,FiltersIds> = [:]
    var _customGroupID: Int32 = 0

    #if swift(>=5.10)
      // This property is used as the initial default value for new instances of the type.
      // The type itself is protecting the reference to its storage via CoW semantics.
      // This will force a copy to be made of this reference when the first mutation occurs;
      // hence, it is safe to mark this as `nonisolated(unsafe)`.
      static nonisolated(unsafe) let defaultInstance = _StorageClass()
    #else
      static let defaultInstance = _StorageClass()
    #endif

    private init() {}

    init(copying source: _StorageClass) {
      _unblockSearchAdsFilterID = source._unblockSearchAdsFilterID
      _cookieNoticeFilterID = source._cookieNoticeFilterID
      _popUpsFilterID = source._popUpsFilterID
      _widgetsFilterID = source._widgetsFilterID
      _otherAnnoyanceFilterID = source._otherAnnoyanceFilterID
      _mobileBannersFilter = source._mobileBannersFilter
      _definedGroups = source._definedGroups
      _groups = source._groups
      _filtersByGroups = source._filtersByGroups
      _recommendedFiltersIdsByGroupDict = source._recommendedFiltersIdsByGroupDict
      _otherFiltersIdsByGroupDict = source._otherFiltersIdsByGroupDict
      _customGroupID = source._customGroupID
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch fieldNumber {
        case 1: try { try decoder.decodeSingularInt32Field(value: &_storage._unblockSearchAdsFilterID) }()
        case 2: try { try decoder.decodeSingularInt32Field(value: &_storage._cookieNoticeFilterID) }()
        case 3: try { try decoder.decodeSingularInt32Field(value: &_storage._popUpsFilterID) }()
        case 4: try { try decoder.decodeSingularInt32Field(value: &_storage._widgetsFilterID) }()
        case 5: try { try decoder.decodeSingularInt32Field(value: &_storage._otherAnnoyanceFilterID) }()
        case 6: try { try decoder.decodeSingularInt32Field(value: &_storage._mobileBannersFilter) }()
        case 7: try { try decoder.decodeSingularMessageField(value: &_storage._definedGroups) }()
        case 8: try { try decoder.decodeRepeatedMessageField(value: &_storage._groups) }()
        case 9: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: &_storage._filtersByGroups) }()
        case 10: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: &_storage._recommendedFiltersIdsByGroupDict) }()
        case 11: try { try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: &_storage._otherFiltersIdsByGroupDict) }()
        case 12: try { try decoder.decodeSingularInt32Field(value: &_storage._customGroupID) }()
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every if/case branch local when no optimizations
      // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
      // https://github.com/apple/swift-protobuf/issues/1182
      if _storage._unblockSearchAdsFilterID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._unblockSearchAdsFilterID, fieldNumber: 1)
      }
      if _storage._cookieNoticeFilterID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._cookieNoticeFilterID, fieldNumber: 2)
      }
      if _storage._popUpsFilterID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._popUpsFilterID, fieldNumber: 3)
      }
      if _storage._widgetsFilterID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._widgetsFilterID, fieldNumber: 4)
      }
      if _storage._otherAnnoyanceFilterID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._otherAnnoyanceFilterID, fieldNumber: 5)
      }
      if _storage._mobileBannersFilter != 0 {
        try visitor.visitSingularInt32Field(value: _storage._mobileBannersFilter, fieldNumber: 6)
      }
      try { if let v = _storage._definedGroups {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      } }()
      if !_storage._groups.isEmpty {
        try visitor.visitRepeatedMessageField(value: _storage._groups, fieldNumber: 8)
      }
      if !_storage._filtersByGroups.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: _storage._filtersByGroups, fieldNumber: 9)
      }
      if !_storage._recommendedFiltersIdsByGroupDict.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: _storage._recommendedFiltersIdsByGroupDict, fieldNumber: 10)
      }
      if !_storage._otherFiltersIdsByGroupDict.isEmpty {
        try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMessageMap<SwiftProtobuf.ProtobufInt32,FiltersIds>.self, value: _storage._otherFiltersIdsByGroupDict, fieldNumber: 11)
      }
      if _storage._customGroupID != 0 {
        try visitor.visitSingularInt32Field(value: _storage._customGroupID, fieldNumber: 12)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersIndex, rhs: FiltersIndex) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._unblockSearchAdsFilterID != rhs_storage._unblockSearchAdsFilterID {return false}
        if _storage._cookieNoticeFilterID != rhs_storage._cookieNoticeFilterID {return false}
        if _storage._popUpsFilterID != rhs_storage._popUpsFilterID {return false}
        if _storage._widgetsFilterID != rhs_storage._widgetsFilterID {return false}
        if _storage._otherAnnoyanceFilterID != rhs_storage._otherAnnoyanceFilterID {return false}
        if _storage._mobileBannersFilter != rhs_storage._mobileBannersFilter {return false}
        if _storage._definedGroups != rhs_storage._definedGroups {return false}
        if _storage._groups != rhs_storage._groups {return false}
        if _storage._filtersByGroups != rhs_storage._filtersByGroups {return false}
        if _storage._recommendedFiltersIdsByGroupDict != rhs_storage._recommendedFiltersIdsByGroupDict {return false}
        if _storage._otherFiltersIdsByGroupDict != rhs_storage._otherFiltersIdsByGroupDict {return false}
        if _storage._customGroupID != rhs_storage._customGroupID {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersGroupedByExtensions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersGroupedByExtensions"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "general"),
    2: .same(proto: "privacy"),
    3: .same(proto: "social"),
    4: .same(proto: "security"),
    5: .same(proto: "other"),
    6: .same(proto: "custom"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedInt32Field(value: &self.general) }()
      case 2: try { try decoder.decodeRepeatedInt32Field(value: &self.privacy) }()
      case 3: try { try decoder.decodeRepeatedInt32Field(value: &self.social) }()
      case 4: try { try decoder.decodeRepeatedInt32Field(value: &self.security) }()
      case 5: try { try decoder.decodeRepeatedInt32Field(value: &self.other) }()
      case 6: try { try decoder.decodeRepeatedInt32Field(value: &self.custom) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.general.isEmpty {
      try visitor.visitPackedInt32Field(value: self.general, fieldNumber: 1)
    }
    if !self.privacy.isEmpty {
      try visitor.visitPackedInt32Field(value: self.privacy, fieldNumber: 2)
    }
    if !self.social.isEmpty {
      try visitor.visitPackedInt32Field(value: self.social, fieldNumber: 3)
    }
    if !self.security.isEmpty {
      try visitor.visitPackedInt32Field(value: self.security, fieldNumber: 4)
    }
    if !self.other.isEmpty {
      try visitor.visitPackedInt32Field(value: self.other, fieldNumber: 5)
    }
    if !self.custom.isEmpty {
      try visitor.visitPackedInt32Field(value: self.custom, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersGroupedByExtensions, rhs: FiltersGroupedByExtensions) -> Bool {
    if lhs.general != rhs.general {return false}
    if lhs.privacy != rhs.privacy {return false}
    if lhs.social != rhs.social {return false}
    if lhs.security != rhs.security {return false}
    if lhs.other != rhs.other {return false}
    if lhs.custom != rhs.custom {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CustomFilterUpdateRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "CustomFilterUpdateRequest"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filterId"),
    2: .same(proto: "title"),
    3: .standard(proto: "is_trusted"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.filterID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.title) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.isTrusted) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.filterID != 0 {
      try visitor.visitSingularInt32Field(value: self.filterID, fieldNumber: 1)
    }
    if !self.title.isEmpty {
      try visitor.visitSingularStringField(value: self.title, fieldNumber: 2)
    }
    if self.isTrusted != false {
      try visitor.visitSingularBoolField(value: self.isTrusted, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CustomFilterUpdateRequest, rhs: CustomFilterUpdateRequest) -> Bool {
    if lhs.filterID != rhs.filterID {return false}
    if lhs.title != rhs.title {return false}
    if lhs.isTrusted != rhs.isTrusted {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FiltersStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FiltersStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "status"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.status) }()
      case 2: try { try decoder.decodeSingularBoolField(value: &self.error) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.status.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.status, fieldNumber: 1)
    }
    if self.error != false {
      try visitor.visitSingularBoolField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FiltersStatus, rhs: FiltersStatus) -> Bool {
    if lhs.status != rhs.status {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension FilterUpdateStatus: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = "FilterUpdateStatus"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .same(proto: "version"),
    3: .same(proto: "success"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularInt32Field(value: &self.id) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._version) }()
      case 3: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if self.id != 0 {
      try visitor.visitSingularInt32Field(value: self.id, fieldNumber: 1)
    }
    try { if let v = self._version {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: FilterUpdateStatus, rhs: FilterUpdateStatus) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs._version != rhs._version {return false}
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
