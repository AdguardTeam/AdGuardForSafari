
/**
 * AdGuard Scriptlets
 * Version 1.1.3
 */

(function () {
    /**
     * Generate random six symbols id
     */
    function randomId() {
        return Math.random().toString(36).substr(2, 9);
    }

    /**
     * Set getter and setter to property if it's configurable
     * @param {Object} object target object with property
     * @param {string} property property name
     * @param {Object} descriptor contains getter and setter functions
     * @returns {boolean} is operation successful
     */
    function setPropertyAccess(object, property, descriptor) {
        var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);

        if (currentDescriptor && !currentDescriptor.configurable) {
            return false;
        }

        Object.defineProperty(object, property, descriptor);
        return true;
    }

    /**
     * @typedef Chain
     * @property {Object} base
     * @property {string} prop
     * @property {string} [chain]
     */

    /**
     * Check is property exist in base object recursively
     *
     * If property doesn't exist in base object,
     * defines this property (for addProp = true)
     * and returns base, property name and remaining part of property chain
     *
     * @param {Object} base
     * @param {string} chain
     * @param {Booleam} addProp - defines is nonexistent base property should be assigned as 'undefined'
     * @returns {Chain}
     */
    function getPropertyInChain(base, chain) {
        var addProp = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
        var pos = chain.indexOf('.');

        if (pos === -1) {
            return {
                base: base,
                prop: chain
            };
        }

        var prop = chain.slice(0, pos);
        var own = base[prop];
        chain = chain.slice(pos + 1);

        if (own !== undefined) {
            return getPropertyInChain(own, chain, addProp);
        }

        if (!addProp) {
            return false;
        }

        Object.defineProperty(base, prop, {
            configurable: true
        });
        return {
            base: own,
            prop: prop,
            chain: chain
        };
    }

    /**
     * Escapes special chars in string
     * @param {string} str
     * @returns {string}
     */
    var escapeRegExp = function escapeRegExp(str) {
        return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };
    /**
     * Converts search string to the regexp
     * TODO think about nested dependencies, but be careful with dependency loops
     * @param {string} str search string
     * @returns {RegExp}
     */

    var toRegExp = function toRegExp(str) {
        if (str[0] === '/' && str[str.length - 1] === '/') {
            return new RegExp(str.slice(1, -1));
        }

        var escaped = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        return new RegExp(escaped);
    };
    /**
     * Get string before regexp first match
     * @param {string} str
     * @param {RegExp} rx
     */

    var getBeforeRegExp = function getBeforeRegExp(str, rx) {
        var index = str.search(rx);
        return str.substring(0, index);
    };
    var startsWith = function startsWith(str, prefix) {
        return str && str.indexOf(prefix) === 0;
    };
    var substringAfter = function substringAfter(str, separator) {
        if (!str) {
            return str;
        }

        var index = str.indexOf(separator);
        return index < 0 ? '' : str.substring(index + separator.length);
    };
    var substringBefore = function substringBefore(str, separator) {
        if (!str || !separator) {
            return str;
        }

        var index = str.indexOf(separator);
        return index < 0 ? str : str.substring(0, index);
    };
    /**
     * Wrap str in double qoutes and replaces single quotes if need
     * @param {string} str
     */

    var wrapInDoubleQuotes = function wrapInDoubleQuotes(str) {
        if (str[0] === '\'' && str[str.length - 1] === '\'') {
            str = str.substring(1, str.length - 1); // eslint-disable-next-line no-useless-escape

            str = str.replace(/\"/g, '\\"');
        } else if (str[0] === '"' && str[str.length - 1] === '"') {
            str = str.substring(1, str.length - 1); // eslint-disable-next-line no-useless-escape

            str = str.replace(/\'/g, '\\\'');
        }

        return "\"".concat(str, "\"");
    };
    /**
     * Returns substring enclosed in the widest braces
     * @param {string} str
     */

    var getStringInBraces = function getStringInBraces(str) {
        var firstIndex = str.indexOf('(');
        var lastIndex = str.lastIndexOf(')');
        return str.substring(firstIndex + 1, lastIndex);
    };

    /**
     * Generates function which silents global errors on page generated by scriptlet
     * If error doesn't belong to our error we transfer it to the native onError handler
     * @param {string} rid - unique identifier of scriptlet
     * @return {onError}
     */
    function createOnErrorHandler(rid) {
        // eslint-disable-next-line consistent-return
        var nativeOnError = window.onerror;
        return function onError(error) {
            if (typeof error === 'string' && error.indexOf(rid) !== -1) {
                return true;
            }

            if (nativeOnError instanceof Function) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                return nativeOnError.apply(this, [error].concat(args));
            }

            return false;
        };
    }

    /**
     * Noop function
     */
    var noop = function noop() {};
    /**
     * Function returns null
     */

    var noopNull = function noopNull() {
        return null;
    };
    /**
     * Function returns this
     */

    function noopThis() {
        return this;
    }
    /**
     * Function returns empty array
     */

    var noopArray = function noopArray() {
        return [];
    };
    /**
     * Function returns empty string
     */

    var noopStr = function noopStr() {
        return '';
    };

    /* eslint-disable no-console, no-underscore-dangle */

    /**
     * Hit used only for debug purposes now
     * @param {Source} source
     * @param {string} message optional message
     */
    var hit = function hit(source, message) {
        if (source.verbose !== true) {
            return;
        }

        try {
            var log = console.log.bind(console);
            var trace = console.trace.bind(console);
            var prefix = source.ruleText || '';

            if (message) {
                log("".concat(prefix, " message:\n").concat(message));
            }

            log("".concat(prefix, " trace start"));

            if (trace) {
                trace();
            }

            log("".concat(prefix, " trace end"));
        } catch (e) {} // try catch for Edge 15
        // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/
        // console.log throws an error
        // This is necessary for unit-tests only!


        if (typeof window.__debugScriptlets === 'function') {
            window.__debugScriptlets(source);
        }
    };

    /**
     * This file must export all used dependencies
     */

    var dependencies = /*#__PURE__*/Object.freeze({
        __proto__: null,
        randomId: randomId,
        setPropertyAccess: setPropertyAccess,
        getPropertyInChain: getPropertyInChain,
        escapeRegExp: escapeRegExp,
        toRegExp: toRegExp,
        getBeforeRegExp: getBeforeRegExp,
        startsWith: startsWith,
        substringAfter: substringAfter,
        substringBefore: substringBefore,
        wrapInDoubleQuotes: wrapInDoubleQuotes,
        getStringInBraces: getStringInBraces,
        createOnErrorHandler: createOnErrorHandler,
        noop: noop,
        noopNull: noopNull,
        noopThis: noopThis,
        noopArray: noopArray,
        noopStr: noopStr,
        hit: hit
    });

    /**
     * Concat dependencies to scriptlet code
     * @param {string} scriptlet string view of scriptlet
     */

    function attachDependencies(scriptlet) {
        var _scriptlet$injections = scriptlet.injections,
            injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
        return injections.reduce(function (accum, dep) {
            return "".concat(accum, "\n").concat(dependencies[dep.name]);
        }, scriptlet.toString());
    }
    /**
     * Add scriptlet call to existing code
     * @param {Function} scriptlet
     * @param {string} code
     */

    function addCall(scriptlet, code) {
        return "".concat(code, ";\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    ");
    }
    /**
     * Wrap function into IIFE (Immediately invoked function expression)
     *
     * @param {Source} source - object with scriptlet properties
     * @param {string} code - scriptlet source code with dependencies
     *
     * @returns {string} full scriptlet code
     *
     * @example
     * const source = {
     *      args: ["aaa", "bbb"],
     *      name: 'noeval',
     * };
     * const code = "function noeval(source, args) { alert(source); } noeval.apply(this, args);"
     * const result = wrapInIIFE(source, code);
     *
     * // result
     * `(function(source, args) {
     *      function noeval(source) { alert(source); }
     *      noeval.apply(this, args);
     * )({"args": ["aaa", "bbb"], "name":"noeval"}, ["aaa", "bbb"])`
     */

    function passSourceAndProps(source, code) {
        if (source.hit) {
            source.hit = source.hit.toString();
        }

        var sourceString = JSON.stringify(source);
        var argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
        var params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
        return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
    }
    /**
     * Wrap code in no name function
     * @param {string} code which must be wrapped
     */

    function wrapInNonameFunc(code) {
        return "function(source, args){\n".concat(code, "\n}");
    }

    function _arrayWithHoles(arr) {
        if (Array.isArray(arr)) return arr;
    }

    var arrayWithHoles = _arrayWithHoles;

    function _iterableToArray(iter) {
        if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
    }

    var iterableToArray = _iterableToArray;

    function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }

    var nonIterableRest = _nonIterableRest;

    function _toArray(arr) {
        return arrayWithHoles(arr) || iterableToArray(arr) || nonIterableRest();
    }

    var toArray = _toArray;

    function _defineProperty(obj, key, value) {
        if (key in obj) {
            Object.defineProperty(obj, key, {
                value: value,
                enumerable: true,
                configurable: true,
                writable: true
            });
        } else {
            obj[key] = value;
        }

        return obj;
    }

    var defineProperty = _defineProperty;

    /**
     * Iterate over iterable argument and evaluate current state with transitions
     * @param {string} init first transition name
     * @param {Array|Collection|string} iterable
     * @param {Object} transitions transtion functions
     * @param {any} args arguments which should be passed to transition functions
     */
    function iterateWithTransitions(iterable, transitions, init, args) {
        var state = init || Object.keys(transitions)[0];

        for (var i = 0; i < iterable.length; i += 1) {
            state = transitions[state](iterable, i, args);
        }

        return state;
    }
    /**
     * AdGuard scriptlet rule mask
     */


    var ADG_SCRIPTLET_MASK = '#//scriptlet';
    /**
     * Helper to accumulate an array of strings char by char
     */

    var wordSaver = function wordSaver() {
        var str = '';
        var strs = [];

        var saveSymb = function saveSymb(s) {
            str += s;
            return str;
        };

        var saveStr = function saveStr() {
            strs.push(str);
            str = '';
        };

        var getAll = function getAll() {
            return [].concat(strs);
        };

        return {
            saveSymb: saveSymb,
            saveStr: saveStr,
            getAll: getAll
        };
    };

    var substringAfter$1 = function substringAfter(str, separator) {
        if (!str) {
            return str;
        }

        var index = str.indexOf(separator);
        return index < 0 ? '' : str.substring(index + separator.length);
    };
    /**
     * Parse and validate scriptlet rule
     * @param {*} ruleText
     * @returns {{name: string, args: Array<string>}}
     */


    var parseRule = function parseRule(ruleText) {
        var _transitions;

        ruleText = substringAfter$1(ruleText, ADG_SCRIPTLET_MASK);
        /**
         * Transition names
         */

        var TRANSITION = {
            OPENED: 'opened',
            PARAM: 'param',
            CLOSED: 'closed'
        };
        /**
         * Transition function: the current index position in start, end or between params
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop symb with current separator char
         */

        var opened = function opened(rule, index, _ref) {
            var sep = _ref.sep;
            var char = rule[index];
            var transition;

            switch (char) {
                case ' ':
                case '(':
                case ',':
                {
                    transition = TRANSITION.OPENED;
                    break;
                }

                case '\'':
                case '"':
                {
                    sep.symb = char;
                    transition = TRANSITION.PARAM;
                    break;
                }

                case ')':
                {
                    transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
                    break;
                }

                default:
                {
                    throw new Error('The rule is not a scriptlet');
                }
            }

            return transition;
        };
        /**
         * Transition function: the current index position inside param
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop `symb` with current separator char
         * @property {Object} Object.saver helper which allow to save strings by car by char
         */


        var param = function param(rule, index, _ref2) {
            var saver = _ref2.saver,
                sep = _ref2.sep;
            var char = rule[index];

            switch (char) {
                case '\'':
                case '"':
                {
                    var preIndex = index - 1;
                    var before = rule[preIndex];

                    if (char === sep.symb && before !== '\\') {
                        sep.symb = null;
                        saver.saveStr();
                        return TRANSITION.OPENED;
                    }
                }
                // eslint-disable-next-line no-fallthrough

                default:
                {
                    saver.saveSymb(char);
                    return TRANSITION.PARAM;
                }
            }
        };

        var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);
        var sep = {
            symb: null
        };
        var saver = wordSaver();
        var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
            sep: sep,
            saver: saver
        });

        if (state !== 'closed') {
            throw new Error("Invalid scriptlet rule ".concat(ruleText));
        }

        var args = saver.getAll();
        return {
            name: args[0],
            args: args.slice(1)
        };
    };

    /* eslint-disable max-len */

    /**
     * @scriptlet abort-on-property-read
     *
     * @description
     * Aborts a script when it attempts to **read** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("abort-on-property-read", <property>)
     * ```
     *
     * **Parameters**
     * - `property` (required) path to a property (joined with `.` if needed). The property must be attached to `window`.
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet("abort-on-property-read", "alert")
     *
     * ! Aborts script when it tries to access `navigator.language`
     * example.org#%#//scriptlet("abort-on-property-read", "navigator.language")
     * ```
     */

    /* eslint-enable max-len */

    function abortOnPropertyRead(source, property) {
        if (!property) {
            return;
        }

        var rid = randomId();

        var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            setPropertyAccess(base, prop, {
                get: abort,
                set: function set() {}
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyRead.names = ['abort-on-property-read', 'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'abp-abort-on-property-read'];
    abortOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet abort-on-property-write
     *
     * @description
     * Aborts a script when it attempts to **write** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("abort-on-property-write", <property>)
     * ```
     *
     * **Parameters**
     * - `property` (required) path to a property (joined with `.` if needed). The property must be attached to `window`.
     *
     * **Examples**
     * ```
     * ! Aborts all inline scripts trying to access `window.alert`
     * utils.escape('<script></script>')
     * // => '&lt;script&gt;&lt;/script&gt;'
     * ```
     */

    /* eslint-enable max-len */

    function abortOnPropertyWrite(source, property) {
        if (!property) {
            return;
        }

        var rid = randomId();

        var abort = function abort() {
            hit(source);
            throw new ReferenceError(rid);
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            setPropertyAccess(base, prop, {
                set: abort
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyWrite.names = ['abort-on-property-write', 'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'abp-abort-on-property-write'];
    abortOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-setTimeout
     *
     * @description
     * Prevents a `setTimeout` call if the text of the callback is matching the specified search string/regexp and (optionally) have the specified delay.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#settimeout-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-setTimeout"[, <search>[, <delay>]])
     * ```
     *
     * **Parameters**
     * - `search` (optional) string or regular expression that must match the stringified callback . If not set, prevents all `setTimeout` calls.
     * - `delay` (optional) must be an integer. If set, it matches the delay passed to the `setTimeout` call.
     *
     * **Examples**
     *
     * 1. Prevents `setTimeout` calls if the callback contains `value` and the delay is set to `300`.
     *     ```
     *     example.org#%#//scriptlet("prevent-setTimeout", "value", "300")
     *     ```
     *
     *     For instance, the followiing call will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 300);
     *     ```
     *
     * 2. Prevents `setTimeout` calls if the callback matches `/\.test/` regardless of the delay.
     *     ```bash
     *     example.org#%#//scriptlet("prevent-setTimeout", "/\.test/")
     *     ```
     *
     *     For instance, the followiing call will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     */

    /* eslint-enable max-len */

    function preventSetTimeout(source, match, delay) {
        var nativeTimeout = window.setTimeout;
        var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

        delay = parseInt(delay, 10);
        delay = nativeIsNaN(delay) ? null : delay;
        match = match ? toRegExp(match) : toRegExp('/.?/');

        var timeoutWrapper = function timeoutWrapper(cb, d) {
            if ((!delay || d === delay) && match.test(cb.toString())) {
                hit(source);
                return nativeTimeout(function () {}, d);
            }

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeTimeout.apply(window, [cb, d].concat(args));
        };

        window.setTimeout = timeoutWrapper;
    }
    preventSetTimeout.names = ['prevent-setTimeout', 'setTimeout-defuser.js', 'ubo-setTimeout-defuser.js', 'std.js', 'ubo-std.js'];
    preventSetTimeout.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-setInterval
     *
     * @description
     * Prevents a `setInterval` call if the text of the callback is matching the specified search string/regexp and (optionally) have the specified interval.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#setinterval-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-setInterval"[, <search>[, <interval>]])
     * ```
     *
     * **Parameters**
     * - `search` (optional) string or regular expression that must match the stringified callback . If not set, prevents all `setInterval` calls.
     * - `interval` (optional) must be an integer. If set, it matches the interval passed to the `setInterval` call.
     *
     * **Example**
     *
     * 1. Prevents `setInterval` calls if the callback contains `value` and the interval is set to `300`.
     *     ```
     *     example.org#%#//scriptlet("prevent-setInterval", "value", "300")
     *     ```
     *
     *     For instance, the followiing call will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 300);
     *     ```
     *
     * 2. Prevents `setInterval` calls if the callback matches `/\.test/` regardless of the interval.
     *     ```
     *     example.org#%#//scriptlet("prevent-setInterval", "/\.test/")
     *     ```
     *
     *     For instance, the followiing call will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     */

    /* eslint-enable max-len */

    function preventSetInterval(source, match, interval) {
        var nativeInterval = window.setInterval;
        var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

        interval = parseInt(interval, 10);
        interval = nativeIsNaN(interval) ? null : interval;
        match = match ? toRegExp(match) : toRegExp('/.?/');

        var intervalWrapper = function intervalWrapper(cb, d) {
            if ((!interval || d === interval) && match.test(cb.toString())) {
                hit(source);
                return nativeInterval(function () {}, d);
            }

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeInterval.apply(window, [cb, d].concat(args));
        };

        window.setInterval = intervalWrapper;
    }
    preventSetInterval.names = ['prevent-setInterval', 'setInterval-defuser.js', 'ubo-setInterval-defuser.js', 'sid.js', 'ubo-sid.js'];
    preventSetInterval.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-window-open
     *
     * @description
     * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-window-open"[, <match>[, <search>]])
     * ```
     *
     * **Parameters**
     * - `match` (optional) defaults to "matching", any positive number for "matching", 0 or any string for "not matching",
     * - `search` (optional) string or regexp for matching the URL passed to `window.open` call.
     *
     * **Example**
     *
     * 1. Prevent all `window.open` calls:
     * ```
     *     example.org#%#//scriptlet("prevent-window-open")
     * ```
     *
     * 2. Prevent `window.open` for all URLs containing `example`:
     * ```
     *     example.org#%#//scriptlet("prevent-window-open", "1", "example")
     * ```
     *
     * 3. Prevent `window.open` for all URLs matching RegExp `/example\./`:
     * ```
     *     example.org#%#//scriptlet("prevent-window-open", "1", "/example\./")
     * ```
     *
     * 4. Prevent `window.open` for all URLs **NOT** containing `example`:
     * ```
     *     example.org#%#//scriptlet("prevent-window-open", "0", "example")
     * ```
     */

    /* eslint-enable max-len */

    function preventWindowOpen(source, inverse, match) {
        var nativeOpen = window.open;
        inverse = inverse ? !+inverse : !!inverse;
        match = match ? toRegExp(match) : toRegExp('/.?/'); // eslint-disable-next-line consistent-return

        var openWrapper = function openWrapper(str) {
            if (inverse === match.test(str)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                return nativeOpen.apply(window, [str].concat(args));
            }

            hit(source);
        };

        window.open = openWrapper;
    }
    preventWindowOpen.names = ['prevent-window-open', 'window.open-defuser.js', 'ubo-window.open-defuser.js'];
    preventWindowOpen.injections = [toRegExp, hit];

    /* eslint-disable no-new-func */
    /* eslint-disable max-len */

    /**
     * @scriptlet abort-current-inline-script
     *
     * @description
     * Aborts an inline script when it attempts to **read** the specified property
     * AND when the contents of the `<script>` element contains the specified
     * text or matches the regular expression.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("abort-current-inline-script", <property> [, <search>])
     * ```
     *
     * **Parameters**
     * - `property` (required) path to a property (joined with `.` if needed). The property must be attached to `window`.
     * - `search` (optional) string or regular expression that must match the inline script contents. If not set, abort all inline scripts which are trying to access the specified property.
     *
     * **Examples**
     * 1. Aborts all inline scripts trying to access `window.alert`
     *     ```
     *     example.org#%#//scriptlet("abort-current-inline-script", "alert")
     *     ```
     *
     * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.
     *     ```
     *     example.org#%#//scriptlet("abort-current-inline-script", "alert", "Hello, world")
     *     ```
     *
     *     For instance, the following script will be aborted
     *     ```html
     *     <script>alert("Hello, world");</script>
     *     ```
     *
     * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.
     *     ```
     *     example.org#%#//scriptlet("abort-current-inline-script", "alert", "/Hello.+world/")
     *     ```
     *
     *     For instance, the following scripts will be aborted:
     *     ```html
     *     <script>alert("Hello, big world");</script>
     *     ```
     *     ```html
     *     <script>alert("Hello, little world");</script>
     *     ```
     *
     *     This script will not be aborted:
     *     ```html
     *     <script>alert("Hi, little world");</script>
     *     ```
     */

    /* eslint-enable max-len */

    function abortCurrentInlineScript(source, property) {
        var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var regex = search ? toRegExp(search) : null;
        var rid = randomId();

        var getCurrentScript = function getCurrentScript() {
            if (!document.currentScript) {
                // eslint-disable-line compat/compat
                var scripts = document.getElementsByTagName('script');
                return scripts[scripts.length - 1];
            }

            return document.currentScript; // eslint-disable-line compat/compat
        };

        var ourScript = getCurrentScript();

        var abort = function abort() {
            var scriptEl = getCurrentScript();
            var content = scriptEl.textContent;

            try {
                var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
                content = textContentGetter.call(scriptEl); // eslint-disable-next-line no-empty
            } catch (e) {}

            if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && (!regex || regex.test(scriptEl.textContent))) {
                hit(source);
                throw new ReferenceError(rid);
            }
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            var currentValue = base[prop];
            setPropertyAccess(base, prop, {
                set: function set(value) {
                    abort();
                    currentValue = value;
                },
                get: function get() {
                    abort();
                    return currentValue;
                }
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    abortCurrentInlineScript.names = ['abort-current-inline-script', 'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'abp-abort-current-inline-script'];
    abortCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet set-constant
     *
     * @description
     * Creates a constant property and assigns it one of the values from the predefined list.
     *
     * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("set-constant", <property>, <value>)
     * ```
     *
     * **Parameters**
     * - `property` (required) path to a property (joined with `.` if needed). The property must be attached to `window`.
     * - `value` (required). Possible values:
     *     - positive decimal integer `<= 32767`
     *     - one of the predefined constants:
     *         - `undefined`
     *         - `false`
     *         - `true`
     *         - `null`
     *         - `noopFunc` - function with empty body
     *         - `trueFunc` - function returning true
     *         - `falseFunc` - function returning false
     *         - `''` - empty string
     *         - `-1` - number value `-1`
     *
     * **Examples**
     * ```
     * ! window.firstConst === false // this comparision will return true
     * example.org#%#//scriptlet("set-constant", "firstConst", "false")
     *
     * ! window.secondConst() === true // call to the secondConst will return true
     * example.org#%#//scriptlet("set-constant", "secondConst", "trueFunc")
     * ```
     */

    /* eslint-enable max-len */

    function setConstant(source, property, value) {
        if (!property) {
            return;
        }

        var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

        var constantValue;

        if (value === 'undefined') {
            constantValue = undefined;
        } else if (value === 'false') {
            constantValue = false;
        } else if (value === 'true') {
            constantValue = true;
        } else if (value === 'null') {
            constantValue = null;
        } else if (value === 'noopFunc') {
            constantValue = function constantValue() {};
        } else if (value === 'trueFunc') {
            constantValue = function constantValue() {
                return true;
            };
        } else if (value === 'falseFunc') {
            constantValue = function constantValue() {
                return false;
            };
        } else if (/^\d+$/.test(value)) {
            constantValue = parseFloat(value);

            if (nativeIsNaN(constantValue)) {
                return;
            }

            if (Math.abs(constantValue) > 0x7FFF) {
                return;
            }
        } else if (value === '-1') {
            constantValue = -1;
        } else if (value === '') {
            constantValue = '';
        } else {
            return;
        }

        var canceled = false;

        var mustCancel = function mustCancel(value) {
            if (canceled) {
                return canceled;
            }

            canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;
            return canceled;
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            if (mustCancel(base[prop])) {
                return;
            }

            hit(source);
            setPropertyAccess(base, prop, {
                get: function get() {
                    return constantValue;
                },
                set: function set(a) {
                    if (mustCancel(a)) {
                        constantValue = a;
                    }
                }
            });
        };

        setChainPropAccess(window, property);
    }
    setConstant.names = ['set-constant', 'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js'];
    setConstant.injections = [getPropertyInChain, setPropertyAccess, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-cookie
     *
     * @description
     * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("remove-cookie"[, match])
     * ```
     *
     * **Parameters**
     * - `match` (optional) String or regex matching the cookie name. If not specified all accessible cookies will be removed.
     *
     * **Examples**
     * 1. Removes all cookies:
     * ```
     *     example.org#%#//scriptlet("remove-cookie")
     * ```
     *
     * 2. Removes cookies which name contains `example` string.
     * ```
     *     example.org#%#//scriptlet("remove-cookie", "example")
     * ```
     *
     *     For instance this cookie will be removed
     *     ```javascript
     *     document.cookie = '__example=randomValue';
     *     ```
     */

    /* eslint-enable max-len */

    function removeCookie(source, match) {
        var regex = match ? toRegExp(match) : toRegExp('/.?/');

        var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
            var cookieSpec = "".concat(cookieName, "=");
            var domain1 = "; domain=".concat(hostName);
            var domain2 = "; domain=.".concat(hostName);
            var path = '; path=/';
            var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
            document.cookie = cookieSpec + expiration;
            document.cookie = cookieSpec + domain1 + expiration;
            document.cookie = cookieSpec + domain2 + expiration;
            document.cookie = cookieSpec + path + expiration;
            document.cookie = cookieSpec + domain1 + path + expiration;
            document.cookie = cookieSpec + domain2 + path + expiration;
            hit(source);
        };

        var rmCookie = function rmCookie() {
            document.cookie.split(';').forEach(function (cookieStr) {
                var pos = cookieStr.indexOf('=');

                if (pos === -1) {
                    return;
                }

                var cookieName = cookieStr.slice(0, pos).trim();

                if (!regex.test(cookieName)) {
                    return;
                }

                var hostParts = document.location.hostname.split('.');

                for (var i = 0; i <= hostParts.length - 1; i += 1) {
                    var hostName = hostParts.slice(i).join('.');

                    if (hostName) {
                        removeCookieFromHost(cookieName, hostName);
                    }
                }
            });
        };

        rmCookie();
        window.addEventListener('beforeunload', rmCookie);
    }
    removeCookie.names = ['remove-cookie', 'cookie-remover.js', 'ubo-cookie-remover.js'];
    removeCookie.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-addEventListener
     *
     * @description
     * Prevents adding event listeners for the specified events and callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-addEventListener"[, eventSearch[, functionSearch]])
     * ```
     *
     * **Parameters**
     * - `eventSearch` (optional) String or regex matching the event name. If not specified, the scriptlets prevents all event listeners.
     * - `functionSearch` (optional) String or regex matching the event listener function body. If not set, the scriptlet prevents all event listeners with event name matching `eventSearch`.
     *
     * **Examples**
     * 1. Prevent all `click` listeners:
     * ```
     *     example.org#%#//scriptlet("prevent-addEventListener", "click")
     * ```

     2. Prevent 'click' listeners with the callback body containing `searchString`.
     * ```
     *     example.org#%#//scriptlet("prevent-addEventListener", "click", "searchString")
     * ```
     *
     *     For instance, this listener will not be called:
     * ```javascript
     *     el.addEventListener('click', () => {
     *         window.test = 'searchString';
     *     });
     * ```
     */

    /* eslint-enable max-len */

    function preventAddEventListener(source, event, funcStr) {
        event = event ? toRegExp(event) : toRegExp('/.?/');
        funcStr = funcStr ? toRegExp(funcStr) : toRegExp('/.?/');
        var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

        function addEventListenerWrapper(eventName, callback) {
            if (event.test(eventName.toString()) && funcStr.test(callback.toString())) {
                hit(source);
                return undefined;
            }

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeAddEventListener.apply(this, [eventName, callback].concat(args));
        }

        window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
    }
    preventAddEventListener.names = ['prevent-addEventListener', 'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js'];
    preventAddEventListener.injections = [toRegExp, hit];

    /* eslint-disable consistent-return, no-eval */
    /**
     * @scriptlet prevent-bab
     *
     * @description
     * Prevents BlockAdblock script from detecting an ad blocker.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-bab")
     * ```
     */

    function preventBab(source) {
        var _this = this;

        var nativeSetTimeout = window.setTimeout;
        var babRegex = /\.bab_elementid.$/;

        window.setTimeout = function (callback) {
            if (typeof callback !== 'string' || !babRegex.test(callback)) {
                for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                    args[_key - 1] = arguments[_key];
                }

                return nativeSetTimeout.call.apply(nativeSetTimeout, [_this, callback].concat(args));
            }

            hit(source);
        };

        var signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];

        var check = function check(str) {
            for (var i = 0; i < signatures.length; i += 1) {
                var tokens = signatures[i];
                var match = 0;

                for (var j = 0; j < tokens.length; j += 1) {
                    var token = tokens[j];
                    var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;

                    if (found) {
                        match += 1;
                    }
                }

                if (match / tokens.length >= 0.8) {
                    return true;
                }
            }

            return false;
        };

        var nativeEval = window.eval;

        window.eval = function (str) {
            if (!check(str)) {
                return nativeEval(str);
            }

            hit(source);
            var bodyEl = document.body;

            if (bodyEl) {
                bodyEl.style.removeProperty('visibility');
            }

            var el = document.getElementById('babasbmsgx');

            if (el) {
                el.parentNode.removeChild(el);
            }
        };
    }
    preventBab.names = ['prevent-bab', 'bab-defuser.js', 'ubo-bab-defuser.js', 'nobab.js', 'ubo-nobab.js'];
    preventBab.injections = [hit];

    /* eslint-disable no-unused-vars, no-extra-bind, func-names */
    /* eslint-disable max-len */

    /**
     * @scriptlet nowebrtc
     *
     * @description
     * Disables WebRTC by overriding `RTCPeerConnection`. The overriden function will log every attempt to create a new connection.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("nowebrtc")
     * ```
     */

    /* eslint-enable max-len */

    function nowebrtc(source) {
        var propertyName = '';

        if (window.RTCPeerConnection) {
            propertyName = 'RTCPeerConnection';
        } else if (window.webkitRTCPeerConnection) {
            propertyName = 'webkitRTCPeerConnection';
        }

        if (propertyName === '') {
            return;
        }

        var rtcReplacement = function rtcReplacement(config) {
            hit(source, "Document tried to create an RTCPeerConnection: ".concat(config));
        };

        var noop = function noop() {};

        rtcReplacement.prototype = {
            close: noop,
            createDataChannel: noop,
            createOffer: noop,
            setRemoteDescription: noop
        };
        var rtc = window[propertyName];
        window[propertyName] = rtcReplacement;

        if (rtc.prototype) {
            rtc.prototype.createDataChannel = function (a, b) {
                return {
                    close: noop,
                    send: noop
                };
            }.bind(null);
        }
    }
    nowebrtc.names = ['nowebrtc', 'nowebrtc.js', 'ubo-nowebrtc.js'];
    nowebrtc.injections = [hit];

    /* eslint-disable no-console */
    /**
     * @scriptlet log-addEventListener
     *
     * @description
     * Logs all addEventListener calls to the console.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("log-addEventListener")
     * ```
     */

    function logAddEventListener(source) {
        var log = console.log.bind(console);
        var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

        function addEventListenerWrapper(eventName, callback) {
            hit(source);
            log("addEventListener(\"".concat(eventName, "\", ").concat(callback.toString(), ")"));

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeAddEventListener.apply(this, [eventName, callback].concat(args));
        }

        window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
    }
    logAddEventListener.names = ['log-addEventListener', 'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js'];
    logAddEventListener.injections = [hit];

    /* eslint-disable no-console */
    /**
     * @scriptlet log-setInterval
     *
     * @description
     * Logs all setInterval calls to the console.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#setinterval-loggerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("log-setInterval")
     * ```
     */

    function logSetInterval(source) {
        var log = console.log.bind(console);
        var nativeSetInterval = window.setInterval;

        function setIntervalWrapper(callback, timeout) {
            hit(source);
            log("setInterval(\"".concat(callback.toString(), "\", ").concat(timeout, ")"));

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeSetInterval.apply(window, [callback, timeout].concat(args));
        }

        window.setInterval = setIntervalWrapper;
    }
    logSetInterval.names = ['log-setInterval', 'setInterval-logger.js', 'ubo-setInterval-logger.js'];
    logSetInterval.injections = [hit];

    /* eslint-disable no-console */
    /**
     * @scriptlet log-setTimeout
     *
     * @description
     * Logs all setTimeout call to the console.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#settimeout-loggerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("log-setTimeout")
     * ```
     */

    function logSetTimeout(source) {
        var log = console.log.bind(console);
        var nativeSetTimeout = window.setTimeout;

        function setTimeoutWrapper(callback, timeout) {
            hit(source);
            log("setTimeout(\"".concat(callback.toString(), "\", ").concat(timeout, ")"));

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeSetTimeout.apply(window, [callback, timeout].concat(args));
        }

        window.setTimeout = setTimeoutWrapper;
    }
    logSetTimeout.names = ['log-setTimeout', 'setTimeout-logger.js', 'ubo-setTimeout-logger.js'];
    logSetTimeout.injections = [hit];

    /* eslint-disable no-console, no-eval */
    /**
     * @scriptlet log-eval
     *
     * @description
     * Logs all `eval()` or `new Function()` calls to the console.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("log-eval")
     * ```
     */

    function logEval(source) {
        var log = console.log.bind(console); // wrap eval function

        var nativeEval = window.eval;

        function evalWrapper(str) {
            hit(source);
            log("eval(\"".concat(str, "\")"));
            return nativeEval(str);
        }

        window.eval = evalWrapper; // wrap new Function

        var nativeFunction = window.Function;

        function FunctionWrapper() {
            hit(source);

            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            log("new Function(".concat(args.join(', '), ")"));
            return nativeFunction.apply(this, [].concat(args));
        }

        FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
        FunctionWrapper.prototype.constructor = FunctionWrapper;
        window.Function = FunctionWrapper;
    }
    logEval.names = ['log-eval'];
    logEval.injections = [hit];

    /**
     * @scriptlet log
     *
     * @description
     * A simple scriptlet which only purpose is to print arguments to console.
     * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.
     * **Example**
     * ```
     * example.org#%#//scriptlet("log", "arg1", "arg2")
     * ```
     */
    function log() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
        }

        console.log(args); // eslint-disable-line no-console
    }
    log.names = ['log'];

    /* eslint-disable no-eval, no-extra-bind */
    /**
     * @scriptlet noeval
     *
     * @description
     * Prevents page to use eval.
     * Notifies about attempts in the console
     *
     * It is mostly used for `$redirect` rules.
     * See [redirect description](../wiki/about-redirects.md#noeval).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("noeval")
     * ```
     */

    function noeval(source) {
        window.eval = function evalWrapper(s) {
            hit(source, "AdGuard has prevented eval:\n".concat(s));
        }.bind();
    }
    noeval.names = ['noeval', 'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js'];
    noeval.injections = [hit];

    /* eslint-disable no-eval, no-extra-bind, func-names */
    /**
     * @scriptlet prevent-eval-if
     *
     * @description
     * Prevents page to use eval matching payload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-
     *
     * **Parameters**
     * - `search` string or regexp matching stringified eval payload
     *
     * **Examples**
     * ```
     * !
     * ```
     *
     * @param {string|RegExp} [search] string or regexp matching stringified eval payload
     */

    function preventEvalIf(source, search) {
        search = search ? toRegExp(search) : toRegExp('/.?/');
        var nativeEval = window.eval;

        window.eval = function (payload) {
            if (!search.test(payload.toString())) {
                return nativeEval.call(window, payload);
            }

            hit(source, payload);
            return undefined;
        }.bind(window);
    }
    preventEvalIf.names = ['prevent-eval-if', 'noeval-if.js', 'ubo-noeval-if.js'];
    preventEvalIf.injections = [toRegExp, hit];

    /* eslint-disable no-console, func-names, no-multi-assign */
    /**
     * @scriptlet prevent-fab-3.2.0
     *
     * @description
     * Prevents execution of the FAB script v3.2.0.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-fab-3.2.0")
     * ```
     */

    function preventFab(source) {
        hit(source);

        var Fab = function Fab() {};

        Fab.prototype.check = noop;
        Fab.prototype.clearEvent = noop;
        Fab.prototype.emitEvent = noop;

        Fab.prototype.on = function (a, b) {
            if (!a) {
                b();
            }

            return this;
        };

        Fab.prototype.onDetected = function () {
            return this;
        };

        Fab.prototype.onNotDetected = function (a) {
            a();
            return this;
        };

        Fab.prototype.setOption = noop;
        window.FuckAdBlock = window.BlockAdBlock = Fab; //

        window.fuckAdBlock = window.blockAdBlock = new Fab();
    }
    preventFab.names = ['prevent-fab-3.2.0', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'nofab.js', 'ubo-nofab.js'];
    preventFab.injections = [noop, hit];

    /* eslint-disable no-console, func-names, no-multi-assign */
    /**
     * @scriptlet set-popads-dummy
     *
     * @description
     * Sets static properties PopAds and popns.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("set-popads-dummy")
     * ```
     */

    function setPopadsDummy(source) {
        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
            PopAds: {
                get: function get() {
                    hit(source);
                    return {};
                }
            },
            popns: {
                get: function get() {
                    hit(source);
                    return {};
                }
            }
        });
    }
    setPopadsDummy.names = ['set-popads-dummy', 'popads-dummy.js', 'ubo-popads-dummy.js'];
    setPopadsDummy.injections = [hit];

    /**
     * @scriptlet prevent-popads-net
     *
     * @description
     * Aborts on property write (PopAds, popns), throws reference error with random id.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-popads-net")
     * ```
     */

    function preventPopadsNet(source) {
        var rid = randomId();

        var throwError = function throwError() {
            throw new ReferenceError(rid);
        };

        delete window.PopAds;
        delete window.popns;
        Object.defineProperties(window, {
            PopAds: {
                set: throwError
            },
            popns: {
                set: throwError
            }
        });
        window.onerror = createOnErrorHandler(rid).bind();
        hit(source);
    }
    preventPopadsNet.names = ['prevent-popads-net', 'popads.net.js', 'ubo-popads.net.js'];
    preventPopadsNet.injections = [createOnErrorHandler, randomId, hit];

    /* eslint-disable func-names */
    /**
     * @scriptlet prevent-adfly
     *
     * @description
     * Prevents anti-adblock scripts on adfly short links.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("prevent-adfly")
     * ```
     */

    function preventAdfly(source) {
        var isDigit = function isDigit(data) {
            return /^\d$/.test(data);
        };

        var handler = function handler(encodedURL) {
            var evenChars = '';
            var oddChars = '';

            for (var i = 0; i < encodedURL.length; i += 1) {
                if (i % 2 === 0) {
                    evenChars += encodedURL.charAt(i);
                } else {
                    oddChars = encodedURL.charAt(i) + oddChars;
                }
            }

            var data = (evenChars + oddChars).split('');

            for (var _i = 0; _i < data.length; _i += 1) {
                if (isDigit(data[_i])) {
                    for (var ii = _i + 1; ii < data.length; ii += 1) {
                        if (isDigit(data[ii])) {
                            // eslint-disable-next-line no-bitwise
                            var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);

                            if (temp < 10) {
                                data[_i] = temp.toString();
                            }

                            _i = ii;
                            break;
                        }
                    }
                }
            }

            data = data.join('');
            var decodedURL = window.atob(data).slice(16, -16);
            /* eslint-disable compat/compat */

            if (window.stop) {
                window.stop();
            }
            /* eslint-enable compat/compat */


            window.onbeforeunload = null;
            window.location.href = decodedURL;
        };

        var val; // Do not apply handler more than one time

        var applyHandler = true;
        var result = setPropertyAccess(window, 'ysmm', {
            configurable: false,
            set: function set(value) {
                if (applyHandler) {
                    applyHandler = false;

                    try {
                        if (typeof value === 'string') {
                            handler(value);
                        }
                    } catch (err) {} // eslint-disable-line no-empty

                }

                val = value;
            },
            get: function get() {
                return val;
            }
        });

        if (result) {
            hit(source);
        } else {
            window.console.error('Failed to set up prevent-adfly scriptlet');
        }
    }
    preventAdfly.names = ['prevent-adfly', 'adfly-defuser.js', 'ubo-adfly-defuser.js'];
    preventAdfly.injections = [setPropertyAccess, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet debug-on-property-read
     *
     * @description
     * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet("debug-on-property-read", "alert")
     * ```
     */

    /* eslint-enable max-len */

    function debugOnPropertyRead(source, property) {
        if (!property) {
            return;
        }

        var rid = randomId();

        var abort = function abort() {
            hit(source); // eslint-disable-next-line no-debugger

            debugger;
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            setPropertyAccess(base, prop, {
                get: abort,
                set: function set() {}
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyRead.names = ['debug-on-property-read'];
    debugOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet debug-on-property-write
     *
     * @description
     * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Aborts script when it tries to write in property `window.test`
     * example.org#%#//scriptlet("debug-on-property-write", "test")
     * ```
     */

    /* eslint-enable max-len */

    function debugOnPropertyWrite(source, property) {
        if (!property) {
            return;
        }

        var rid = randomId();

        var abort = function abort() {
            hit(source); // eslint-disable-next-line no-debugger

            debugger;
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            setPropertyAccess(base, prop, {
                set: abort
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyWrite.names = ['debug-on-property-write'];
    debugOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit];

    /* eslint-disable no-new-func */
    /* eslint-disable max-len */

    /**
     * @scriptlet debug-current-inline-script
     *
     * @description
     * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     *```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet("debug-current-inline-script", "alert")
     * ```
     */

    /* eslint-enable max-len */

    function debugCurrentInlineScript(source, property) {
        var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var regex = search ? toRegExp(search) : null;
        var rid = randomId();

        var getCurrentScript = function getCurrentScript() {
            if (!document.currentScript) {
                // eslint-disable-line compat/compat
                var scripts = document.getElementsByTagName('script');
                return scripts[scripts.length - 1];
            }

            return document.currentScript; // eslint-disable-line compat/compat
        };

        var ourScript = getCurrentScript();

        var abort = function abort() {
            var scriptEl = getCurrentScript();

            if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!regex || regex.test(scriptEl.textContent))) {
                hit(source); // eslint-disable-next-line no-debugger

                debugger;
            }
        };

        var setChainPropAccess = function setChainPropAccess(owner, property) {
            var chainInfo = getPropertyInChain(owner, property);
            var base = chainInfo.base;
            var prop = chainInfo.prop,
                chain = chainInfo.chain;

            if (chain) {
                var setter = function setter(a) {
                    base = a;

                    if (a instanceof Object) {
                        setChainPropAccess(a, chain);
                    }
                };

                Object.defineProperty(owner, prop, {
                    get: function get() {
                        return base;
                    },
                    set: setter
                });
                return;
            }

            var currentValue = base[prop];
            setPropertyAccess(base, prop, {
                set: function set(value) {
                    abort();
                    currentValue = value;
                },
                get: function get() {
                    abort();
                    return currentValue;
                }
            });
        };

        setChainPropAccess(window, property);
        window.onerror = createOnErrorHandler(rid).bind();
    }
    debugCurrentInlineScript.names = ['debug-current-inline-script'];
    debugCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-attr
     *
     * @description
     * Removes the specified attributes from DOM notes. This scriptlet runs only once after the page load (DOMContentLoaded).
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("remove-attr", attrs[, selector])
     * ```
     *
     * - `attrs`  required, attribute or list of attributes joined by '|';
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the attributes will be removed
     *
     * **Examples**
     * 1.  Removes by attribute
     *     ```
     *     example.org#%#//scriptlet("remove-attr", "example|test")
     *     ```
     *
     *     ```html
     *     <!-- before  -->
     *     <div example="true" test="true">Some text</div>
     *
     *     <!-- after -->
     *     <div>Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet("remove-attr", "example", ".inner")
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper" example="true">
     *         <div class="inner" example="true">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper" example="true">
     *         <div class="inner">Some text</div>
     *     </div>
     *     ```
     */

    /* eslint-enable max-len */

    function removeAttr(source, attrs, selector) {
        if (!attrs) {
            return;
        }

        attrs = attrs.split(/\s*\|\s*/);

        if (!selector) {
            selector = "[".concat(attrs.join('],['), "]");
        }

        var rmattr = function rmattr(ev) {
            if (ev) {
                window.removeEventListener(ev.type, rmattr, true);
            }

            var nodes = [].slice.call(document.querySelectorAll(selector));
            var removed = false;
            nodes.forEach(function (node) {
                attrs.forEach(function (attr) {
                    node.removeAttribute(attr);
                    removed = true;
                });
            });

            if (removed) {
                hit(source);
            }
        };

        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', rmattr, true);
        } else {
            rmattr();
        }
    }
    removeAttr.names = ['remove-attr', 'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js'];
    removeAttr.injections = [hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-class
     *
     * @description
     * Removes the specified classes from DOM notes. This scriptlet runs only once after the page load (DOMContentLoaded).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("remove-class", classes[, selector])
     * ```
     *
     * - `classes`  required, class or list of classes separated by '|';
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the classes will be removed;
     * if there is no selector, every class independently will be removed from all nodes which has one
     *
     * **Examples**
     * 1.  Removes by classes
     *     ```
     *     example.org#%#//scriptlet("remove-class", "example|test")
     *     ```
     *
     *     ```html
     *     <!-- before  -->
     *     <div id="first" class="nice test">Some text</div>
     *     <div id="second" class="rare example for test">Some text</div>
     *     <div id="third" class="testing better example">Some text</div>
     *
     *     <!-- after -->
     *     <div id="first" class="nice">Some text</div>
     *     <div id="second" class="rare for">Some text</div>
     *     <div id="third" class="testing better">Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet("remove-class", "branding", ".inner")
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad branding">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad">Some text</div>
     *     </div>
     *     ```
     */

    /* eslint-enable max-len */

    function removeClass(source, classNames, selector) {
        if (!classNames) {
            return;
        }

        classNames = classNames.split(/\s*\|\s*/);
        var selectors = [];

        if (!selector) {
            selectors = classNames.map(function (className) {
                return ".".concat(className);
            });
        }

        var removeClassHandler = function removeClassHandler(ev) {
            if (ev) {
                window.removeEventListener(ev.type, removeClassHandler, true);
            }

            var nodes = new Set();

            if (selector) {
                var foundedNodes = [].slice.call(document.querySelectorAll(selector));
                foundedNodes.forEach(function (n) {
                    return nodes.add(n);
                });
            } else if (selectors.length > 0) {
                selectors.forEach(function (s) {
                    var elements = document.querySelectorAll(s);

                    for (var i = 0; i < elements.length; i += 1) {
                        var element = elements[i];
                        nodes.add(element);
                    }
                });
            }

            var removed = false;
            nodes.forEach(function (node) {
                classNames.forEach(function (className) {
                    if (node.classList.contains(className)) {
                        node.classList.remove(className);
                        removed = true;
                    }
                });
            });

            if (removed) {
                hit(source);
            }
        };

        if (document.readyState === 'loading') {
            window.addEventListener('DOMContentLoaded', removeClassHandler, true);
        } else {
            removeClassHandler();
        }
    }
    removeClass.names = ['remove-class'];
    removeClass.injections = [hit];

    /**
     * @scriptlet disable-newtab-links
     *
     * @description
     * Prevents opening new tabs and windows if there is `target` attribute in element.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("disable-newtab-links")
     * ```
     */

    function disableNewtabLinks(source) {
        document.addEventListener('click', function (ev) {
            var target = ev.target;

            while (target !== null) {
                if (target.localName === 'a' && target.hasAttribute('target')) {
                    ev.stopPropagation();
                    ev.preventDefault();
                    hit(source);
                    break;
                }

                target = target.parentNode;
            }
        });
    }
    disableNewtabLinks.names = ['disable-newtab-links', 'disable-newtab-links.js', 'ubo-disable-newtab-links.js'];
    disableNewtabLinks.injections = [hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet adjust-setInterval
     *
     * @description
     * Adjusts interval for specified setInterval() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("adjust-setInterval"[, match [, interval[, boost]]])
     * ```
     *
     * - `match` - optional, string/regular expression, matching in stringified callback function
     * - `interval` - optional, defaults to 1000, decimal integer, matching interval
     * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down, interval multiplier
     *
     * **Examples**
     * 1. Adjust all setInterval() x20 times where interval equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet("adjust-setInterval")
     *     ```
     *
     * 2. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 1000ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setInterval", "example")
     *     ```
     *
     * 3. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 400ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setInterval", "example", "400")
     *     ```
     *
     * 4. Slow down setInterval() x2 times where callback matched with `example` and interval equal 400ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setInterval", "example", "400", "2")
     *     ```
     */

    /* eslint-enable max-len */

    function adjustSetInterval(source, match, interval, boost) {
        var nativeInterval = window.setInterval;
        var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

        var nativeIsFinite = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat

        interval = parseInt(interval, 10);
        interval = nativeIsNaN(interval) ? 1000 : interval;
        boost = parseInt(boost, 10);
        boost = nativeIsNaN(interval) || !nativeIsFinite(boost) ? 0.05 : boost;
        match = match ? toRegExp(match) : toRegExp('/.?/');

        if (boost < 0.02) {
            boost = 0.02;
        }

        if (boost > 50) {
            boost = 50;
        }

        var intervalWrapper = function intervalWrapper(cb, d) {
            if (d === interval && match.test(cb.toString())) {
                d *= boost;
                hit(source);
            }

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeInterval.apply(window, [cb, d].concat(args));
        };

        window.setInterval = intervalWrapper;
    }
    adjustSetInterval.names = ['adjust-setInterval', 'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js'];
    adjustSetInterval.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet adjust-setTimeout
     *
     * @description
     * Adjusts timeout for specified setTimout() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("adjust-setTimeout"[, match [, timeout[, boost]]])
     * ```
     *
     * - `match` - optional, string/regular expression, matching in stringified callback function
     * - `timeout` - optional, defaults to 1000, decimal integer, matching interval
     * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down, interval multiplier
     *
     * **Examples**
     * 1. Adjust all setTimeout() x20 times where interval equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet("adjust-setTimeout")
     *     ```
     *
     * 2. Adjust all setTimeout() x20 times where callback mathed with `example` and interval equal 1000ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setTimeout", "example")
     *     ```
     *
     * 3. Adjust all setTimeout() x20 times where callback mathed with `example` and interval equal 400ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setTimeout", "example", "400")
     *     ```
     *
     * 4. Slow down setTimeout() x2 times where callback matched with `example` and interval equal 400ms
     *     ```
     *     example.org#%#//scriptlet("adjust-setTimeout", "example", "400", "2")
     *     ```
     */

    /* eslint-enable max-len */

    function adjustSetTimeout(source, match, timeout, boost) {
        var nativeTimeout = window.setTimeout;
        var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

        var nativeIsFinite = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat

        timeout = parseInt(timeout, 10);
        timeout = nativeIsNaN(timeout) ? 1000 : timeout;
        boost = parseInt(boost, 10);
        boost = nativeIsNaN(timeout) || !nativeIsFinite(boost) ? 0.05 : boost;
        match = match ? toRegExp(match) : toRegExp('/.?/');

        if (boost < 0.02) {
            boost = 0.02;
        }

        if (boost > 50) {
            boost = 50;
        }

        var timeoutWrapper = function timeoutWrapper(cb, d) {
            if (d === timeout && match.test(cb.toString())) {
                d *= boost;
                hit(source);
            }

            for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
            }

            return nativeTimeout.apply(window, [cb, d].concat(args));
        };

        window.setTimeout = timeoutWrapper;
    }
    adjustSetTimeout.names = ['adjust-setTimeout', 'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js'];
    adjustSetTimeout.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet dir-string
     *
     * @description
     * Wraps the `console.dir` API to call the `toString` method of the argument.
     * There are several adblock circumvention systems that detect browser devtools
     * and hide themselves. Therefore, if we force them to think
     * that devtools are open (using this scrciptlet),
     * it will automatically disable the adblock circumvention script.
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("dir-string"[, times])
     * ```
     * - `times` - optional, the number of times to call the `toString` method of the argument to `console.dir`
     *
     * **Example**
     * ```
     * ! Run 2 times
     * example.org#%#//scriptlet("dir-string", "2")
     * ```
     */

    /* eslint-enable max-len */

    function dirString(source, times) {
        var _console = console,
            dir = _console.dir;
        times = parseInt(times, 10);

        function dirWrapper(object) {
            // eslint-disable-next-line no-unused-vars
            var temp;

            for (var i = 0; i < times; i += 1) {
                // eslint-disable-next-line no-unused-expressions
                temp = "".concat(object);
            }

            if (typeof dir === 'function') {
                dir.call(this, object);
            }

            hit(source, temp);
        } // eslint-disable-next-line no-console


        console.dir = dirWrapper;
    }
    dirString.names = ['dir-string', 'abp-dir-string'];
    dirString.injections = [hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet json-prune
     *
     * @description
     * Removes specified properties from the result of calling JSON.parse and returns the caller
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet("json-prune"[, propsToRemove [, obligatoryProps]])
     * ```
     *
     * - `propsToRemove` - string of space-separated properties to remove
     * - `obligatoryProps` - optional, string of space-separated properties which must be all present for the pruning to occur
     *
     * **Examples**
     * 1. Removes property `example` from the results of JSON.parse call
     *     ```
     *     example.org#%#//scriptlet("json-prune", "example")
     *     ```
     *
     *     For instance, the following call will return `{ one: 1}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"example":true}')
     *     ```
     *
     * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur
     *     ```
     *     example.org#%#//scriptlet("json-prune", "one", "obligatoryProp")
     *     ```
     *
     *     For instance, the following call will return `{ one: 1, two: 2}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"two":2}')
     *     ```
     *
     * 3. A property in a list of properties can be a chain of properties
     *
     *     ```
     *     example.org#%#//scriptlet("json-prune", "a.b", "adpath.url.first")
     *     ```
     *
     * 4. Call with no arguments will log the current hostname and json payload at the console
     *     ```
     *     example.org#%#//scriptlet("json-prune")
     *     ```
     */

    /* eslint-enable max-len */

    function jsonPrune(source, propsToRemove, requiredInitialProps) {
        // eslint-disable-next-line no-console
        var log = console.log.bind(console);
        var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
        var needlePaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];

        function isPruningNeeded(root) {
            if (!root) {
                return false;
            }

            for (var i = 0; i < needlePaths.length; i += 1) {
                var needlePath = needlePaths[i];
                var details = getPropertyInChain(root, needlePath, false);
                var nestedPropName = needlePath.split('').pop();

                if (details && details.base[nestedPropName] === undefined) {
                    return false;
                }
            }

            return true;
        }

        var nativeParse = JSON.parse;

        var parseWrapper = function parseWrapper() {
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
            }

            var r = nativeParse.apply(window, args);

            if (prunePaths.length === 0) {
                log(window.location.hostname, r);
                return r;
            }

            if (isPruningNeeded(r) === false) {
                return r;
            }

            prunePaths.forEach(function (path) {
                var ownerObj = getPropertyInChain(r, path, false);

                if (ownerObj !== undefined && ownerObj.base) {
                    delete ownerObj.base[ownerObj.prop];
                }
            });
            hit(source);
            return r;
        };

        JSON.parse = parseWrapper;
    }
    jsonPrune.names = ['json-prune', 'json-prune.js', 'ubo-json-prune.js'];
    jsonPrune.injections = [hit, getPropertyInChain];

    /**
     * This file must export all scriptlets which should be accessible
     */

    var scriptletsList = /*#__PURE__*/Object.freeze({
        __proto__: null,
        abortOnPropertyRead: abortOnPropertyRead,
        abortOnPropertyWrite: abortOnPropertyWrite,
        preventSetTimeout: preventSetTimeout,
        preventSetInterval: preventSetInterval,
        preventWindowOpen: preventWindowOpen,
        abortCurrentInlineScript: abortCurrentInlineScript,
        setConstant: setConstant,
        removeCookie: removeCookie,
        preventAddEventListener: preventAddEventListener,
        preventBab: preventBab,
        nowebrtc: nowebrtc,
        logAddEventListener: logAddEventListener,
        logSetInterval: logSetInterval,
        logSetTimeout: logSetTimeout,
        logEval: logEval,
        log: log,
        noeval: noeval,
        preventEvalIf: preventEvalIf,
        preventFab: preventFab,
        setPopadsDummy: setPopadsDummy,
        preventPopadsNet: preventPopadsNet,
        preventAdfly: preventAdfly,
        debugOnPropertyRead: debugOnPropertyRead,
        debugOnPropertyWrite: debugOnPropertyWrite,
        debugCurrentInlineScript: debugCurrentInlineScript,
        removeAttr: removeAttr,
        removeClass: removeClass,
        disableNewtabLinks: disableNewtabLinks,
        adjustSetInterval: adjustSetInterval,
        adjustSetTimeout: adjustSetTimeout,
        dirString: dirString,
        jsonPrune: jsonPrune
    });

    var COMMENT_MARKER = '!';
    /**
     * AdGuard scriptlet rule
     */

    var ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/; // eslint-disable-next-line no-template-curly-in-string

    var ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})'; // eslint-disable-next-line no-template-curly-in-string

    var ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
    /**
     * uBlock scriptlet rule mask
     */

    var UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
    var UBO_SCRIPTLET_MASK_1 = '##+js';
    var UBO_SCRIPTLET_MASK_2 = '##script:inject';
    var UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
    var UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject'; // eslint-disable-next-line no-template-curly-in-string

    var UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})'; // eslint-disable-next-line no-template-curly-in-string

    var UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
    var UBO_ALIAS_NAME_MARKER = 'ubo-';
    /**
     * AdBlock Plus snippet rule mask
     */

    var ABP_SCRIPTLET_MASK = '#$#';
    var ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
    /**
     * AdGuard CSS rule mask
     */

    var ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
    /**
     * Returns array of strings separated by space which not in quotes
     * @param {string} str
     */

    var getSentences = function getSentences(str) {
        var reg = /'.*?'|".*?"|\S+/g;
        return str.match(reg);
    };
    /**
     * Replaces string with data by placeholders
     * @param {string} str
     * @param {Object} data - where keys are placeholders names
     */


    var replacePlaceholders = function replacePlaceholders(str, data) {
        return Object.keys(data).reduce(function (acc, key) {
            var reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
            acc = acc.replace(reg, data[key]);
            return acc;
        }, str);
    };
    /**
     * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)
     * @param {string} rule
     * @return {boolean}
     */


    var isComment = function isComment(rule) {
        return startsWith(rule, COMMENT_MARKER);
    };
    /**
     * Checks is AdGuard scriptlet rule
     * @param {string} rule rule text
     */


    var isAdgScriptletRule = function isAdgScriptletRule(rule) {
        return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
    };
    /**
     * Checks is uBO scriptlet rule
     * @param {string} rule rule text
     */

    var isUboScriptletRule = function isUboScriptletRule(rule) {
        return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
    };
    /**
     * Checks is AdBlock Plus snippet
     * @param {string} rule rule text
     */

    var isAbpSnippetRule = function isAbpSnippetRule(rule) {
        return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
    };
    /**
     * Converts string of UBO scriptlet rule to AdGuard scritlet rule
     * @param {string} rule - UBO scriptlet rule
     * @returns {Array} - array with one AdGuard scriptlet rule
     */

    var convertUboToAdg = function convertUboToAdg(rule) {
        var domains = getBeforeRegExp(rule, UBO_SCRIPTLET_MASK_REG);
        var mask = rule.match(UBO_SCRIPTLET_MASK_REG)[0];
        var template;

        if (mask.indexOf('@') > -1) {
            template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
        } else {
            template = ADGUARD_SCRIPTLET_TEMPLATE;
        }

        var args = getStringInBraces(rule).split(/, /g).map(function (arg, index) {
            var outputArg;

            if (index === 0) {
                outputArg = arg.indexOf('.js') > -1 ? "ubo-".concat(arg) : "ubo-".concat(arg, ".js");
            } else {
                outputArg = arg;
            }

            return outputArg;
        }).map(function (arg) {
            return wrapInDoubleQuotes(arg);
        }).join(', ');
        var adgRule = replacePlaceholders(template, {
            domains: domains,
            args: args
        });
        return [adgRule];
    };
    /**
     * Convert string of ABP scriptlet rule to AdGuard scritlet rule
     * @param {string} rule - ABP scriptlet rule
     * @returns {Array} - array of AdGuard scriptlet rules -
     * one or few items depends on Abp-rule
     */

    var convertAbpToAdg = function convertAbpToAdg(rule) {
        var SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
        var mask = rule.indexOf(ABP_SCRIPTLET_MASK) > -1 ? ABP_SCRIPTLET_MASK : ABP_SCRIPTLET_EXCEPTION_MASK;
        var template = mask === ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
        var domains = substringBefore(rule, mask);
        var args = substringAfter(rule, mask);
        return args.split(SEMICOLON_DIVIDER).map(function (args) {
            return getSentences(args).filter(function (arg) {
                return arg;
            }).map(function (arg, index) {
                return index === 0 ? "abp-".concat(arg) : arg;
            }).map(function (arg) {
                return wrapInDoubleQuotes(arg);
            }).join(', ');
        }).map(function (args) {
            return replacePlaceholders(template, {
                domains: domains,
                args: args
            });
        });
    };
    /**
     * Converts scriptlet rule to AdGuard one
     * @param {string} rule
     * @returns {Array} - array of AdGuard scriptlet rules -
     * one item for Adg and Ubo or few items for Abp
     */

    var convertScriptletToAdg = function convertScriptletToAdg(rule) {
        var result;

        if (isUboScriptletRule(rule)) {
            result = convertUboToAdg(rule);
        } else if (isAbpSnippetRule(rule)) {
            result = convertAbpToAdg(rule);
        } else if (isAdgScriptletRule(rule) || isComment(rule)) {
            result = [rule];
        }

        return result;
    };
    /**
     * Converts UBO scriptlet rule to AdGuard one
     * @param {string} rule - AdGuard scriptlet rule
     * @returns {string} - UBO scriptlet rule
     */

    var convertAdgToUbo = function convertAdgToUbo(rule) {
        var res;

        if (isAdgScriptletRule(rule)) {
            var _parseRule = parseRule(rule),
                parsedName = _parseRule.name,
                parsedParams = _parseRule.args; // object of name and aliases for the Adg-scriptlet


            var adgScriptletObject = Object.keys(scriptletsList).map(function (el) {
                return scriptletsList[el];
            }).map(function (s) {
                var _s$names = toArray(s.names),
                    name = _s$names[0],
                    aliases = _s$names.slice(1);

                return {
                    name: name,
                    aliases: aliases
                };
            }).find(function (el) {
                return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
            });
            var aliases = adgScriptletObject.aliases;

            if (aliases.length > 0) {
                var uboAlias = adgScriptletObject.aliases // eslint-disable-next-line no-restricted-properties
                    .find(function (alias) {
                        return alias.includes(UBO_ALIAS_NAME_MARKER);
                    });

                if (uboAlias) {
                    var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
                    var template;

                    if (mask.indexOf('@') > -1) {
                        template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
                    } else {
                        template = UBO_SCRIPTLET_TEMPLATE;
                    }

                    var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
                    var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '');
                    var args = parsedParams.length > 0 ? "".concat(uboName, ", ").concat(parsedParams.join(', ')) : uboName;
                    var uboRule = replacePlaceholders(template, {
                        domains: domains,
                        args: args
                    });
                    res = uboRule;
                }
            }
        }

        return res;
    };

    /**
     * @typedef {Object} Source - scriptlet properties
     * @property {string} name Scriptlet name
     * @property {Array<string>} args Arguments for scriptlet function
     * @property {'extension'|'corelibs'} engine Defines the final form of scriptlet string presentation
     * @property {string} [version]
     * @property {boolean} [verbose] flag to enable printing to console debug information
     * @property {string} [ruleText] Source rule text is used for debugging purposes
     */

    /**
     * Find scriptlet by it's name
     * @param {string} name
     */

    function getScriptletByName(name) {
        var scriptlets = Object.keys(scriptletsList).map(function (key) {
            return scriptletsList[key];
        });
        return scriptlets.find(function (s) {
            return s.names && s.names.indexOf(name) > -1;
        });
    }
    /**
     * Checks if the scriptlet name is valid
     * @param {string} name - Scriptlet name
     */


    function isValidScriptletName(name) {
        if (!name) {
            return false;
        }

        var scriptlet = getScriptletByName(name);

        if (!scriptlet) {
            return false;
        }

        return true;
    }
    /**
     * Returns scriptlet code by param
     * @param {Source} source
     */


    function getScriptletCode(source) {
        if (!isValidScriptletName(source.name)) {
            return null;
        }

        var scriptlet = getScriptletByName(source.name);
        var result = attachDependencies(scriptlet);
        result = addCall(scriptlet, result);
        result = source.engine === 'corelibs' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);
        return result;
    }
    /**
     * Validates any scriptlet rule
     * @param {string} input - can be Adguard or Ubo or Abp scriptlet rule
     */


    function isValidScriptletRule(input) {
        if (!input) {
            return false;
        } // ABP 'input' rule may contain more than one snippet


        var rulesArray = convertScriptletToAdg(input); // checking if each of parsed scriptlets is valid
        // if at least one of them is not valid - whole 'input' rule is not valid too

        var isValid = rulesArray.reduce(function (acc, rule) {
            var parsedRule = parseRule(rule);
            return isValidScriptletName(parsedRule.name) && acc;
        }, true);
        return isValid;
    }
    /**
     * Global scriptlet variable
     *
     * @returns {Object} object with methods:
     * `invoke` method receives one argument with `Source` type
     * `validate` method receives one argument with `String` type
     */

    var scriptlets$1 = {
        invoke: getScriptletCode,
        validateName: isValidScriptletName,
        validateRule: isValidScriptletRule,
        isAdgScriptletRule: isAdgScriptletRule,
        isUboScriptletRule: isUboScriptletRule,
        isAbpSnippetRule: isAbpSnippetRule,
        convertUboToAdg: convertUboToAdg,
        convertAbpToAdg: convertAbpToAdg,
        convertScriptletToAdg: convertScriptletToAdg,
        convertAdgToUbo: convertAdgToUbo
    };

    scriptlets = scriptlets$1;

}());

/**
 * -------------------------------------------
 * |                                         |
 * |  If you want to add your own scriptlet  |
 * |  please put your code below             |
 * |                                         |
 * -------------------------------------------
 */