# SPDX-FileCopyrightText: AdGuard Software Limited
#
# SPDX-License-Identifier: GPL-3.0-or-later

require 'tmpdir'
require 'rexml/document'

require_relative 'Config'

desc 'Create appcast for standalone builds'
desc 'Options:'
desc '  - output (required): PATH Path to new appcast file. MUST BE ONLY NEW'
desc '  - updates (required): PATH Path to folder with new app version'
desc '  - sparkle (required): PATH Path to sparkle generate_appcast binary'
desc '  - release_notes_url (required): URL Release notes url for this build'
desc '  - channel (optional): STRING Channel for generate appcast. Must be one of [release, beta, nightly, dev]. Default is "release" (aka Sparkle "default") channel'
desc '  - download_url_prefix (optional): URL Prefix of AdGuard Mini package. Default is "ADGUARD_UPDATE_BASE_URL/channel"'
lane :generate_appcast do |options|
  output = options[:output]
  updates = options[:updates]
  sparkle = options[:sparkle]
  release_notes_url = options[:release_notes_url]
  channel = options[:channel]
  download_url_prefix = options[:download_url_prefix]
  download_url_prefix = nil if download_url_prefix == ''
  is_critical_update = options[:is_critical_update]
  is_critical_update = false if is_critical_update.nil?

  UI.user_error!("Missing argument: 'channel:<String>'") if channel.nil?

  if download_url_prefix.nil?
    download_url_prefix = "#{@build_settings['ADGUARD_UPDATE_BASE_URL']}/#{channel}/"
  end

  UI.user_error!("Missing argument: 'output:<PATH>'") if output.nil?
  UI.user_error!("Missing argument: 'updates:<PATH>'") if updates.nil?
  UI.user_error!("Missing argument: 'sparkle:<PATH>'") if sparkle.nil?
  UI.user_error!("Missing argument: 'release_notes_url:<URL>'") if release_notes_url.nil?

  Dir.mktmpdir do |temp_dir|
    key_path = create_edsa_signature_file(temp_dir)

    command = make_sparkle_command(
      sparkle,
      output,
      key_path,
      updates,
      nil,
      download_url_prefix,
      is_critical_update
    )

    sh(
      command,
      error_callback: lambda { |error_output|
        UI.user_error!("Failed to sign update: #{error_output}")
      },
      step_name: '(Re)Generate appcast'
    )
  end

  modify_appcast(output, release_notes_url, channel)
end

def make_sparkle_command(
  sparkle,
  output,
  key_path,
  updates,
  channel,
  download_url_prefix,
  is_critical_update
)
  command = [
    sparkle,
    '--phased-rollout-interval', '86400',
    '--maximum-versions', '1',
    '-o', output,
    '--ed-key-file', key_path,
    updates
  ]

  unless channel.nil?
    command.append('--channel')
    command.append(channel)
  end

  unless download_url_prefix.nil?
    command.append('--download-url-prefix')
    command.append(download_url_prefix)
  end

  if is_critical_update
    command.append('--critical-update-version')
    # An empty string argument will treat this update as critical coming from any application version
    command.append('""')
  end

  command
end

def modify_appcast(appcast, release_notes_url, channel)
  xml_data = File.read(appcast)
  doc = REXML::Document.new(xml_data)

  release_notes_link_element_name = 'sparkle:releaseNotesLink'
  item = nil
  all_items = doc.elements['rss/channel']
  all_items.elements.each do |element|
    if element.name == 'item' && element.elements[release_notes_link_element_name].nil?
      item = element
      break
    end
  end

  return if item.nil?

  release_notes_url_element = REXML::Element.new(release_notes_link_element_name)
  release_notes_url_element.add(REXML::CData.new(release_notes_url))
  item.insert_after(item.elements['pubDate'], release_notes_url_element)

  formatter = REXML::Formatters::Pretty.new
  formatter.compact = true

  File.open(appcast, 'w') do |file|
    formatter.write(doc, file)
  end
end
