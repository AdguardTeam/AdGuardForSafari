# SPDX-FileCopyrightText: AdGuard Software Limited
#
# SPDX-License-Identifier: GPL-3.0-or-later

# frozen_string_literal: true

# Version management and utility functions for dependency updates

def parse_target_packages(packages)
  return nil unless packages

  target_packages = packages.split(',').map(&:strip)

  # Validate that all specified packages exist
  invalid_packages = target_packages - DefaultUpdateConstants::ALL_PACKAGES

  if invalid_packages.any?
    UI.error("Unknown packages: #{invalid_packages.join(', ')}")
    UI.message("Available packages:")
    UI.message("  npm: #{DefaultUpdateConstants::NPM_PACKAGES.join(', ')}")
    UI.message("  SPM: #{DefaultUpdateConstants::SPM_PACKAGES.join(', ')}")
    return nil
  end

  target_packages
end

def validate_environment_variables
  unless defined?(@root_path) && @root_path
    UI.error('Root path not initialized')
    return false
  end

  unless defined?(@project_file) && @project_file
    UI.error('Project file path not initialized')
    return false
  end

  true
end

def get_latest_git_version(repo_url, package_identity = nil, version_pattern = nil)
  # Unified git version fetching with better error handling
  begin
    UI.message("  Fetching latest git tags for #{package_identity || 'package'}...")

    # Use more compatible git command
    result = sh("git ls-remote --tags #{repo_url} 2>/dev/null | grep -v '\\^{}'", log: false).strip
    return nil if result.empty?

    # Extract and filter version tags
    version_tags = []
    result.split("\n").each do |line|
      tag = line.split("\t").last.gsub('refs/tags/', '')
      next if tag.empty?

      # Apply version pattern if provided, otherwise use default semantic versioning
      pattern = version_pattern || /^v?(\d+\.\d+\.\d+)$/
      if tag.match(pattern)
        version = tag.match(pattern)[1] || tag
        version_tags << version
      end
    end

    return nil if version_tags.empty?

    # Sort and return latest version
    latest_version = version_tags.sort_by { |v| version_to_comparable(v) }.last
    UI.success("  Latest version: #{latest_version}")

    latest_version
  rescue StandardError => e
    UI.error("  Failed to fetch latest version: #{e.message}")
    nil
  end
end

def print_table(headers, rows)
  return if rows.empty?

  # Calculate column widths
  col_widths = headers.map(&:length)
  rows.each do |row|
    row.each_with_index do |cell, i|
      col_widths[i] = [col_widths[i], cell.to_s.length].max
    end
  end

  # Print header
  header_line = headers.map.with_index { |h, i| h.ljust(col_widths[i]) }.join(' | ')
  UI.important(header_line)
  UI.message('-' * header_line.length)

  # Print rows with color coding based on status
  rows.each do |row|
    row_line = row.map.with_index { |cell, i| cell.to_s.ljust(col_widths[i]) }.join(' | ')

    # Color code based on status (last column)
    status = row.last.to_s.downcase
    case status
    when 'update available'
      UI.success(row_line)
    when 'up to date'
      UI.message(row_line)
    when /failed|error/
      UI.error(row_line)
    else
      UI.message(row_line)
    end
  end
end

def version_to_comparable_array(version)
  # Convert version string to array of integers for comparison
  # Handle various version formats: 1.2.3, v1.2.3, 1.2.3-rc.1, etc.
  version.gsub(/^v/, '').split(/[.-]/).map do |part|
    # Convert numeric parts to integers, keep text parts as strings with high sort value
    if part.match(/^\d+$/)
      part.to_i
    else
      # For non-numeric parts (like 'rc', 'beta'), assign a high value to sort them after numeric
      1000 + part.hash.abs % 1000
    end
  end
end

def print_summary(title, items)
  return if items.empty?

  UI.header(title + ':')
  items.each { |item| UI.success("  â€¢ #{item}") }
end

def version_to_comparable(version)
  # Convert version to array for sorting
  version.split('.').map(&:to_i)
end

def version_compare(version1, version2)
  # Compare two version strings, return -1, 0, or 1
  v1_parts = version1.split('.').map(&:to_i)
  v2_parts = version2.split('.').map(&:to_i)

  # Pad to same length
  max_length = [v1_parts.length, v2_parts.length].max
  v1_parts += [0] * (max_length - v1_parts.length)
  v2_parts += [0] * (max_length - v2_parts.length)

  v1_parts <=> v2_parts
end

def extract_version_number(version_spec)
  # Extract version number from semantic version spec (^1.2.3 -> 1.2.3)
  version_spec.gsub(/^[^\d]*/, '')
end

def preserve_version_prefix(old_version, new_version)
  # Extract prefix from old version (^, ~, >=, etc.)
  match = old_version.match(/^[^\d]*/)
  prefix = match ? match.to_s : ''
  "#{prefix}#{new_version}"
end

def version_satisfies_spec?(version, version_spec)
  # Check if a version satisfies a semantic version specification
  match = version_spec.match(/^[^\d]*/)
  prefix = match ? match.to_s : ''
  base_version = extract_version_number(version_spec)

  case prefix
  when '^'
    # Caret: compatible within same major version
    satisfies_caret?(version, base_version)
  when '~'
    # Tilde: compatible within same minor version
    satisfies_tilde?(version, base_version)
  when '>='
    # Greater than or equal
    version_compare(version, base_version) >= 0
  when '>'
    # Greater than
    version_compare(version, base_version) > 0
  when '<='
    # Less than or equal
    version_compare(version, base_version) <= 0
  when '<'
    # Less than
    version_compare(version, base_version) < 0
  else
    # Exact match
    version == base_version
  end
end

def satisfies_caret?(version, base_version)
  # ^1.2.3 allows >=1.2.3 but <2.0.0
  v_parts = version.split('.').map(&:to_i)
  b_parts = base_version.split('.').map(&:to_i)

  return false if v_parts[0] != b_parts[0] # Different major version

  version_compare(version, base_version) >= 0
end

def satisfies_tilde?(version, base_version)
  # ~1.2.3 allows >=1.2.3 but <1.3.0
  v_parts = version.split('.').map(&:to_i)
  b_parts = base_version.split('.').map(&:to_i)

  return false if v_parts[0] != b_parts[0] || v_parts[1] != b_parts[1] # Different major/minor

  version_compare(version, base_version) >= 0
end

def get_compatible_version(package_name, version_spec)
  # Get all available versions
  result = `npm view #{package_name} versions --json 2>/dev/null`.strip
  all_versions = JSON.parse(result)

  # Find the highest compatible version
  compatible_versions = all_versions.select do |version|
    version_satisfies_spec?(version, version_spec)
  end

  return version_spec if compatible_versions.empty?

  # Get the highest compatible version and preserve the original prefix
  highest_version = compatible_versions.max_by { |v| version_to_comparable(v) }
  preserve_version_prefix(version_spec, highest_version)
rescue StandardError => e
  UI.important("Could not fetch versions for #{package_name}: #{e.message}")
  version_spec
end

def get_npm_latest_version(package_name)
  result = `npm view #{package_name}@latest version 2>/dev/null`.strip
  result.empty? ? nil : result
rescue StandardError => e
  UI.important("Could not fetch latest version for #{package_name}: #{e.message}")
  nil
end

def with_retry(retries: 3)
  attempt = 0
  begin
    attempt += 1
    yield
  rescue StandardError => e
    raise e unless attempt < retries

    UI.important("Attempt #{attempt} failed, retrying... (#{e.message})")
    sleep(2)
    retry
  end
end
