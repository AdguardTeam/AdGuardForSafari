# SPDX-FileCopyrightText: AdGuard Software Limited
#
# SPDX-License-Identifier: GPL-3.0-or-later

require 'pathname'
require 'tmpdir'

require_relative 'Config'
import 'CertificateProcessing'

desc 'Build App and archive'
desc 'Options:'
desc Config::CONFIG_OPTION_DOC
desc '  - notarize (optional): BOOL Notarize bundle. Default is true'
desc "  - obtain_version (optional): BOOL Create version.txt with version and build number inside 'build' folder. Default false"
lane :build do |options|
  config = @config
  check_configuration(config)
  export_type = config == 'MAS' ? 'app-store' : 'developer-id'

  product_name = @build_settings['PRODUCT_NAME']
  xcarchive_name = "#{product_name}.xcarchive"
  xcarchive_zip_name = "#{xcarchive_name}.zip".delete(' ')
  app_bundle_name = "#{product_name}.app"
  app_bundle_zip_name = "#{app_bundle_name}.zip".delete(' ')

  clean
  # Sync certificates and provisioning profiles
  certs(config: config)

  # Fix lane context for Standalone builds after match
  Actions.lane_context[SharedValues::MATCH_PROVISIONING_PROFILE_MAPPING] = {} if config != 'MAS'
  Actions.lane_context[SharedValues::SIGH_PROFILE_TYPE] = export_type

  build_mac_app(
    project: @project_file,
    scheme: @scheme,
    configuration: config,
    output_directory: @build_path,
    clean: true,
    include_bitcode: false, # Deprecated in xcodebuild, crashed with error "cannot upload bitcode because bitcode is imbalanced"
    include_symbols: false,
    archive_path: "#{@build_path}/#{xcarchive_name}",
    derived_data_path: "#{@build_path}/derived_data",
    buildlog_path: "#{@build_path}/logs",
    build_path: @build_path,
    xcargs: '-skipPackagePluginValidation',
    export_method: export_type,
    export_options: {
      manageAppVersionAndBuildNumber: false
    }
  )

  if config != 'MAS'
    if options[:notarize] == false
      UI.important 'Notarizing is disabled'
    else
      notari(config: config, bundle: app_bundle_name, id: @build_settings['AG_APP_ID'])
    end
  end
  # zip the archives so that we could use them as a build artifacts
  zip(
    "#{@build_path}/#{app_bundle_name}",
    "#{@build_path}/#{app_bundle_zip_name}"
  )

  zip(
    "#{@build_path}/#{xcarchive_name}",
    "#{@build_path}/#{xcarchive_zip_name}"
  )

  if options[:obtain_version]
    inject_version = @build_settings['AG_VERSION']
    inject_build_number = @build_settings['AG_BUILD']
    inject_channel = @build_settings['AG_CHANNEL']
    inject_base_version_name = "#{inject_version}.#{inject_build_number}"
    inject_version_name = "#{inject_base_version_name}-#{inject_channel}"
    sh(
      "printf 'version=#{inject_version}\nbuild_number=#{inject_build_number}\nchannel=#{inject_channel}\nbase_version_name=#{inject_base_version_name}\nversion_name=#{inject_version_name}\n' > \"#{@build_path}/version.txt\"",
      step_name: 'Obtain version'
    )
  end
end

desc 'Notarize bundle using default credentials'
desc 'Required options:'
desc Config::CONFIG_OPTION_DOC
desc '  - bundle: STRING Path to bundle, must be defined relatively to BUILD_PATH'
desc '  - id: STRING Bundle id, used for notary service'
lane :notari do |options|
  UI.user_error!("Missing argument: 'id:<BUNDLE_ID>'") if options[:id].nil?
  UI.user_error!("Missing argument: 'bundle:<BUNDLE_PATH_RELATIVE_TO_BUILD_DIR>'") if options[:bundle].nil?

  bundle_path = "#{@build_path}/#{options[:bundle]}"
  bundle_id = options[:id]

  notariz(bundle_path: bundle_path, bundle_id: bundle_id)
end

def check_configuration(config)
  UI.user_error!("Unknown configuration: #{config}") unless Config::AVAILABLE_BUILD_CONFIGS.include?(config)
end

def clean
  FastlaneCore::CommandExecutor.execute(
    command: "rm -rf '#{@build_path}'",
    print_all: true,
    error: proc do |error_output|
      UI.error("Failed to run clean: #{error_output}")
    end
  )
end
